import json
from pathlib import Path
from exporter.base_exporter import BaseExporter

# NES APU register addresses
APU_PULSE1_CTRL = 0x4000
APU_PULSE1_SWEEP = 0x4001
APU_PULSE1_TIMER_LO = 0x4002
APU_PULSE1_TIMER_HI = 0x4003

APU_PULSE2_CTRL = 0x4004
APU_PULSE2_SWEEP = 0x4005
APU_PULSE2_TIMER_LO = 0x4006
APU_PULSE2_TIMER_HI = 0x4007

APU_TRIANGLE_CTRL = 0x4008
APU_TRIANGLE_TIMER_LO = 0x400A
APU_TRIANGLE_TIMER_HI = 0x400B

APU_NOISE_CTRL = 0x400C
APU_NOISE_PERIOD = 0x400E
APU_NOISE_LENGTH = 0x400F

APU_DMC_CTRL = 0x4010
APU_DMC_LOAD = 0x4011
APU_DMC_ADDR = 0x4012
APU_DMC_LEN = 0x4013

APU_STATUS = 0x4015

# NES note frequency table (NTSC)
# These are timer values for the APU pulse/triangle channels
NOTE_TABLE_NTSC = [
    # C    C#   D    D#   E    F    F#   G    G#   A    A#   B
    1712, 1616, 1525, 1440, 1357, 1281, 1209, 1141, 1077, 1017, 961, 907,  # Octave 1
    856,  808,  762,  720,  678,  640,  604,  570,  538,  508,  480, 453,   # Octave 2
    428,  404,  381,  360,  339,  320,  302,  285,  269,  254,  240, 226,   # Octave 3
    214,  202,  190,  180,  170,  160,  151,  143,  135,  127,  120, 113,   # Octave 4
    107,  101,  95,   90,   85,   80,   76,   71,   67,   64,   60,  57,    # Octave 5
    53,   50,   48,   45,   42,   40,   38,   36,   34,   32,   30,  28,    # Octave 6
    27,   25,   24,   22,   21,   20,   19,   18,   17,   16,   15,  14,    # Octave 7
    13,   13,   12,   11,   11,   10,   9,    9,    8,    8,    7,   7      # Octave 8
]

# Noise period table
NOISE_PERIODS = [4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068]


class CA65Exporter(BaseExporter):
    def __init__(self):
        super().__init__()
        
    def midi_note_to_timer_value(self, midi_note):
        if midi_note < 24 or midi_note > 119:  # Valid range for NES
            return 0
        return NOTE_TABLE_NTSC[midi_note - 24]

    def export_tables_with_patterns(self, frames, patterns, references, output_path, standalone=True):
        lines = []
        lines.append("; CA65 Assembly Export (Pattern Compressed)")
        lines.append("; Generated by MIDI2NES")
        lines.append("")
        lines.append(".importzp ptr1, temp1, temp2, frame_counter")
        lines.append("")
        
        # Add header segment if standalone
        if standalone:
            lines.append('.segment "HEADER"')
            lines.append('    .byte "NES", $1A')
            lines.append('    .byte $01        ; 16K PRG ROM')
            lines.append('    .byte $01        ; 8K CHR ROM')
            lines.append('    .byte $00        ; Mapper 0')
            lines.append('    .byte $00        ; System type')
            lines.append('')
        
        # Pattern data goes in RODATA
        lines.append(".segment \"RODATA\"")
        lines.append("")
        
        # Add note table
        lines.append("note_table:")
        for i, note_val in enumerate(NOTE_TABLE_NTSC[:48]):  # First 4 octaves
            lines.append(f"    .word {note_val}  ; Note {i}")
        lines.append("")
        
        # Add frame data
        lines.append("frame_data:")
        lines.append("    .word 0  ; Placeholder frame data")
        lines.append("")
        
        # Add pattern data
        lines.append("; Pattern Data")
        for pattern_id, pattern in patterns.items():
            lines.append(f"{pattern_id}:")
            for event in pattern['events']:
                if 'note' in event:
                    timer_val = self.midi_note_to_timer_value(event['note'])
                    volume = min(15, max(0, event['volume']))
                    lines.append(f"    .byte ${volume:02X}, ${timer_val & 0xFF:02X}, ${(timer_val >> 8) & 0x07:02X}")
            lines.append("")
        
        # Build frame-to-pattern mapping from pattern references
        frame_to_pattern = {}
        max_frame = 0
        
        if references:
            for frame_str, pattern_info in references.items():
                # Convert string frame to integer
                frame_num = int(frame_str)
                pattern_id, offset = pattern_info
                frame_to_pattern[frame_num] = (pattern_id, offset)
                max_frame = max(max_frame, frame_num)
        
        # Export pattern reference table
        lines.append("; Pattern Reference Table")
        lines.append("pattern_refs:")
        for frame in range(max_frame + 1):
            if frame in frame_to_pattern:
                pattern_id, offset = frame_to_pattern[frame]
                lines.append(f"    .word {pattern_id}")
                lines.append(f"    .byte {offset}")
            else:
                lines.append("    .word 0")
                lines.append("    .byte 0")
        lines.append("")
        
        # Add the music engine code
        lines.extend([
            "; Music Engine Code",
            ".segment \"CODE\"",
            "",
            ".global init_music",  # Use .global instead of .export
            "init_music:",
            "    ; Initialize APU",
            "    lda #$0F",
            "    sta $4015   ; Enable all channels except DMC",
            "    lda #$30",
            "    sta $4000   ; Set up Pulse 1",
            "    sta $4004   ; Set up Pulse 2",
            "    sta $4008   ; Set up Triangle",
            "    lda #$00",
            "    sta $400C   ; Set up Noise",
            "    rts",
            "",
            ".global update_music",  # Use .global instead of .export
            "update_music:",
            "    ; Get current frame",
            "    lda frame_counter",
            "    jsr _play_pattern_frame  ; Use local label",
            "    ; Increment frame counter",
            "    inc frame_counter",
            "    bne @skip_high",
            "    inc frame_counter+1",
            "@skip_high:",
            "    rts",
            "",
            "; Local subroutine",
            "_play_pattern_frame:",  # Changed to local label
            "    ; Input: A = frame number",
            "    ; Preserves X, Y",
            "    asl",
            "    asl  ; Multiply by 4 (3 bytes per entry)",
            "    tax",
            "    ",
            "    ; Get pattern pointer and offset",
            "    lda pattern_refs,x",
            "    sta ptr1",
            "    lda pattern_refs+1,x",
            "    sta ptr1+1",
            "    lda pattern_refs+2,x",
            "    sta temp1",
            "    ",
            "    ; Check if we have a pattern",
            "    lda ptr1+1",
            "    ora ptr1",
            "    beq @silent_frame",
            "    ",
            "    ; Get pattern data",
            "    ldy temp1",
            "    lda (ptr1),y",
            "    sta temp2  ; Store volume",
            "    iny",
            "    lda (ptr1),y",
            "    tax       ; Store timer_lo",
            "    iny",
            "    lda (ptr1),y",
            "    tay       ; Store timer_hi",
            "    jmp @play_frame",
            "    ",
            "@silent_frame:",
            "    lda #$00",
            "    sta temp2  ; Zero volume",
            "    tax       ; Zero timer_lo",
            "    tay       ; Zero timer_hi",
            "    ",
            "@play_frame:",
            "    ; Play the frame data",
            "    lda temp2",
            "    sta $4000  ; Set volume",
            "    txa",
            "    sta $4002  ; Set timer low",
            "    tya",
            "    sta $4003  ; Set timer high",
            "    rts"
        ])
        
        # Add aliases for the required labels
        lines.append("")
        lines.append("; Required label aliases")
        lines.append("init:")
        lines.append("    jmp init_music")
        lines.append("play:")
        lines.append("    jmp update_music")
        lines.append("")
        
        # Add vectors segment if standalone
        if standalone:
            lines.append('.segment "VECTORS"')
            lines.append('    .word 0         ; NMI vector')
            lines.append('    .word init      ; RESET vector')
            lines.append('    .word 0         ; IRQ vector')
            lines.append('')
        
        # Write to file
        with open(output_path, 'w') as f:
            f.write('\n'.join(lines))

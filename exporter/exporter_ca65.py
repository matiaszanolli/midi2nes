import json
from pathlib import Path
from exporter.base_exporter import BaseExporter

# NES APU register addresses
APU_PULSE1_CTRL = 0x4000
APU_PULSE1_SWEEP = 0x4001
APU_PULSE1_TIMER_LO = 0x4002
APU_PULSE1_TIMER_HI = 0x4003

APU_PULSE2_CTRL = 0x4004
APU_PULSE2_SWEEP = 0x4005
APU_PULSE2_TIMER_LO = 0x4006
APU_PULSE2_TIMER_HI = 0x4007

APU_TRIANGLE_CTRL = 0x4008
APU_TRIANGLE_TIMER_LO = 0x400A
APU_TRIANGLE_TIMER_HI = 0x400B

APU_NOISE_CTRL = 0x400C
APU_NOISE_PERIOD = 0x400E
APU_NOISE_LENGTH = 0x400F

APU_DMC_CTRL = 0x4010
APU_DMC_LOAD = 0x4011
APU_DMC_ADDR = 0x4012
APU_DMC_LEN = 0x4013

APU_STATUS = 0x4015

# NES note frequency table (NTSC)
# These are timer values for the APU pulse/triangle channels
NOTE_TABLE_NTSC = [
    # C    C#   D    D#   E    F    F#   G    G#   A    A#   B
    1712, 1616, 1525, 1440, 1357, 1281, 1209, 1141, 1077, 1017, 961, 907,  # Octave 1
    856,  808,  762,  720,  678,  640,  604,  570,  538,  508,  480, 453,   # Octave 2
    428,  404,  381,  360,  339,  320,  302,  285,  269,  254,  240, 226,   # Octave 3
    214,  202,  190,  180,  170,  160,  151,  143,  135,  127,  120, 113,   # Octave 4
    107,  101,  95,   90,   85,   80,   76,   71,   67,   64,   60,  57,    # Octave 5
    53,   50,   48,   45,   42,   40,   38,   36,   34,   32,   30,  28,    # Octave 6
    27,   25,   24,   22,   21,   20,   19,   18,   17,   16,   15,  14,    # Octave 7
    13,   13,   12,   11,   11,   10,   9,    9,    8,    8,    7,   7      # Octave 8
]

# Noise period table
NOISE_PERIODS = [4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068]


class CA65Exporter(BaseExporter):
    def __init__(self):
        super().__init__()
        
    def midi_note_to_timer_value(self, midi_note):
        if midi_note < 24 or midi_note > 119:  # Valid range for NES
            return 0
        return NOTE_TABLE_NTSC[midi_note - 24]

    def export_direct_frames(self, frames, output_path, standalone=True):
        """Export frames data directly using efficient lookup tables"""
        print("ðŸ”§ CA65 Exporter: Direct frame export mode (table-based)")

        lines = []
        lines.append("; CA65 Assembly Export (Direct Frame Data)")
        lines.append("; Generated by MIDI2NES - Optimized Table-Based Exporter")
        lines.append("")

        # Add header segment if standalone
        if standalone:
            lines.append('.segment "HEADER"')
            lines.append('    .byte "NES", $1A')
            lines.append('    .byte $08        ; 128K PRG ROM (MMC1)')
            lines.append('    .byte $00        ; No CHR ROM')
            lines.append('    .byte $10        ; Mapper 1 (MMC1)')
            lines.append('    .byte $00        ; System type')
            lines.append('')

        # Zero page variables
        if not standalone:
            # Import zeropage from main.asm
            lines.append('.importzp frame_counter, temp_ptr')
            lines.append('')
        else:
            # Define our own zeropage
            lines.append('.segment "ZEROPAGE"')
            lines.append('frame_counter: .res 2')
            lines.append('temp_ptr: .res 2')
            lines.append('')

        # BSS segment for last note tracking (prevents buzzing)
        lines.append('.segment "BSS"')
        lines.append('last_pulse1_note: .res 1')
        lines.append('last_pulse2_note: .res 1')
        lines.append('last_triangle_note: .res 1')
        lines.append('')

        # Get all channels and find maximum frame
        all_channels = {}
        max_frame = 0

        for channel_name, channel_data in frames.items():
            if channel_data:  # Skip empty channels
                all_channels[channel_name] = channel_data
                channel_max = max(int(f) for f in channel_data.keys())
                max_frame = max(max_frame, channel_max)

        print(f"  Channels: {list(all_channels.keys())}")
        print(f"  Max frame: {max_frame}")
        print(f"  Total frames to export: {max_frame + 1}")

        # Generate ROM data segment with frame tables
        lines.append('.segment "RODATA"')
        lines.append('')

        # Create sparse frame lookup tables for each channel
        # Format: For each active frame, store (note, control_byte, timer_lo, timer_hi)
        for channel_name in ['pulse1', 'pulse2', 'triangle']:
            if channel_name not in all_channels:
                continue

            channel_data = all_channels[channel_name]
            lines.append(f'; {channel_name.upper()} Frame Data Tables')

            # Create arrays that are indexed by frame number
            # We use $00 for empty frames (silent)
            note_table = []
            control_table = []
            timer_lo_table = []
            timer_hi_table = []

            for frame_num in range(max_frame + 1):
                frame_str = str(frame_num)
                if frame_str in channel_data:
                    frame_data = channel_data[frame_str]
                    pitch = frame_data.get('pitch', 0)
                    note = frame_data.get('note', 0)

                    # Triangle channel uses different control format
                    if channel_name == 'triangle':
                        # Triangle: bit 7 = control flag, bits 6-0 = linear counter
                        # Use volume (if available) to set linear counter
                        volume = frame_data.get('volume', 0)
                        # FIXED: If volume is 0, control must be 0 (silent), not 0x80!
                        if volume == 0:
                            control = 0x00
                        else:
                            control = 0x80 | (volume * 7)  # Control flag + linear counter
                    else:
                        # Pulse channels: use provided control byte
                        control = frame_data.get('control', 0)

                    note_table.append(f"${note:02X}")
                    control_table.append(f"${control:02X}")
                    timer_lo_table.append(f"${pitch & 0xFF:02X}")
                    timer_hi_table.append(f"${((pitch >> 8) & 0x07):02X}")
                else:
                    # Empty frame - silence
                    note_table.append("$00")
                    control_table.append("$00")
                    timer_lo_table.append("$00")
                    timer_hi_table.append("$00")

            # Write tables in chunks of 16 bytes per line
            lines.append(f'{channel_name}_note:')
            for i in range(0, len(note_table), 16):
                chunk = note_table[i:i+16]
                lines.append(f'    .byte {", ".join(chunk)}')

            lines.append(f'{channel_name}_control:')
            for i in range(0, len(control_table), 16):
                chunk = control_table[i:i+16]
                lines.append(f'    .byte {", ".join(chunk)}')

            lines.append(f'{channel_name}_timer_lo:')
            for i in range(0, len(timer_lo_table), 16):
                chunk = timer_lo_table[i:i+16]
                lines.append(f'    .byte {", ".join(chunk)}')

            lines.append(f'{channel_name}_timer_hi:')
            for i in range(0, len(timer_hi_table), 16):
                chunk = timer_hi_table[i:i+16]
                lines.append(f'    .byte {", ".join(chunk)}')
            lines.append('')

        # Code segment with efficient playback routine
        lines.append('.segment "CODE"')
        lines.append('')

        # Add reset routine ONLY if standalone
        if standalone:
            lines.extend([
            '.proc reset',
            '    ; Standard NES initialization',
            '    sei',
            '    cld',
            '    ldx #$FF',
            '    txs',
            '    ',
            '    ; PPU warmup',
            '    bit $2002',
            '@wait_vbl1:',
            '    bit $2002',
            '    bpl @wait_vbl1',
            '@wait_vbl2:',
            '    bit $2002',
            '    bpl @wait_vbl2',
            '    ',
            '    ; APU initialization',
            '    lda #$00',
            '    sta $4015',
            '    lda #$40',
            '    sta $4017',
            '    lda #$0F',
            '    sta $4015',
            '    ',
            '    ; Initialize frame counter',
            '    lda #$00',
            '    sta frame_counter',
            '    sta frame_counter+1',
            '    ',
            '    ; Enable NMI',
            '    lda #$80',
            '    sta $2000',
            '    ',
            '@main_loop:',
            '    jmp @main_loop',
            '.endproc',
            '',
            '.proc nmi',
            '    ; Save registers',
            '    pha',
            '    txa',
            '    pha',
            '    tya',
            '    pha',
            '    ',
            '    ; Play current frame',
            '    jsr play_music_frame',
            '    ',
            '    ; Increment frame counter',
            '    inc frame_counter',
            '    bne @no_carry',
            '    inc frame_counter+1',
            '@no_carry:',
            '    ',
            '    ; Check for song end and loop',
            f'    lda frame_counter+1',
            f'    cmp #>{max_frame}',
            f'    bcc @no_loop',
            f'    bne @loop_song',
            f'    lda frame_counter',
            f'    cmp #<{max_frame}',
            f'    bcc @no_loop',
            '@loop_song:',
            '    lda #$00',
            '    sta frame_counter',
            '    sta frame_counter+1',
            '@no_loop:',
            '    ; Restore registers',
            '    pla',
            '    tay',
            '    pla',
            '    tax',
            '    pla',
            '    rti',
            '.endproc',
            ''
            ])

        # Efficient table-based playback routine with 16-bit addressing
        lines.append('.proc play_music_frame')
        lines.append('    ; Check if frame is within range')
        lines.append(f'    lda frame_counter+1')
        lines.append(f'    cmp #>{max_frame}')
        lines.append('    bcc @in_range')
        lines.append('    bne @done')
        lines.append(f'    lda frame_counter')
        lines.append(f'    cmp #<{max_frame}')
        lines.append('    bcs @done')
        lines.append('@in_range:')
        lines.append('')

        # Generate playback code for each channel with 16-bit indexing
        if 'pulse1' in all_channels:
            lines.extend([
                '    ; === PULSE1 CHANNEL ===',
                '    jsr play_pulse1',
                ''
            ])

        if 'pulse2' in all_channels:
            lines.extend([
                '    ; === PULSE2 CHANNEL ===',
                '    jsr play_pulse2',
                ''
            ])

        if 'triangle' in all_channels:
            lines.extend([
                '    ; === TRIANGLE CHANNEL ===',
                '    jsr play_triangle',
                ''
            ])

        lines.extend([
            '@done:',
            '    rts',
            '.endproc',
            ''
        ])

        # Add channel-specific playback subroutines
        if 'pulse1' in all_channels:
            lines.extend([
                '.proc play_pulse1',
                '    ; Get note number for this frame',
                '    lda #<pulse1_note',
                '    clc',
                '    adc frame_counter',
                '    sta temp_ptr',
                '    lda #>pulse1_note',
                '    adc frame_counter+1',
                '    sta temp_ptr+1',
                '    ldy #0',
                '    lda (temp_ptr),y',
                '    ',
                '    ; Check if note changed',
                '    cmp last_pulse1_note',
                '    beq @sustain           ; Same note - sustain, don\'t retrigger',
                '    sta last_pulse1_note   ; Different note - update tracker',
                '    ',
                '    ; Note changed - check if new note is silence',
                '    beq @silence           ; If note is 0, silence the channel',
                '    ',
                '    ; New note - write full channel state',
                '    ; Get and write control byte',
                '    lda #<pulse1_control',
                '    clc',
                '    adc frame_counter',
                '    sta temp_ptr',
                '    lda #>pulse1_control',
                '    adc frame_counter+1',
                '    sta temp_ptr+1',
                '    lda (temp_ptr),y',
                '    sta $4000',
                '    ',
                '    ; Get and write timer low',
                '    lda #<pulse1_timer_lo',
                '    clc',
                '    adc frame_counter',
                '    sta temp_ptr',
                '    lda #>pulse1_timer_lo',
                '    adc frame_counter+1',
                '    sta temp_ptr+1',
                '    lda (temp_ptr),y',
                '    sta $4002',
                '    ',
                '    ; Get and write timer high with length counter reload',
                '    lda #<pulse1_timer_hi',
                '    clc',
                '    adc frame_counter',
                '    sta temp_ptr',
                '    lda #>pulse1_timer_hi',
                '    adc frame_counter+1',
                '    sta temp_ptr+1',
                '    lda (temp_ptr),y',
                '    ora #$08               ; Set length reload for new notes',
                '    sta $4003',
                '    rts',
                '    ',
                '@silence:',
                '    ; Silence the channel',
                '    lda #$30               ; Zero volume, duty 0',
                '    sta $4000',
                '    rts',
                '    ',
                '@sustain:',
                '    ; Note is sustaining - do nothing to avoid phase reset',
                '    rts',
                '.endproc',
                ''
            ])

        if 'pulse2' in all_channels:
            lines.extend([
                '.proc play_pulse2',
                '    ; Get note number for this frame',
                '    lda #<pulse2_note',
                '    clc',
                '    adc frame_counter',
                '    sta temp_ptr',
                '    lda #>pulse2_note',
                '    adc frame_counter+1',
                '    sta temp_ptr+1',
                '    ldy #0',
                '    lda (temp_ptr),y',
                '    ',
                '    ; Check if note changed',
                '    cmp last_pulse2_note',
                '    beq @sustain',
                '    sta last_pulse2_note',
                '    ',
                '    ; Note changed - check if silence',
                '    beq @silence',
                '    ',
                '    ; New note - write full channel state',
                '    ; Get and write control byte',
                '    lda #<pulse2_control',
                '    clc',
                '    adc frame_counter',
                '    sta temp_ptr',
                '    lda #>pulse2_control',
                '    adc frame_counter+1',
                '    sta temp_ptr+1',
                '    lda (temp_ptr),y',
                '    sta $4004',
                '    ',
                '    ; Get and write timer low',
                '    lda #<pulse2_timer_lo',
                '    clc',
                '    adc frame_counter',
                '    sta temp_ptr',
                '    lda #>pulse2_timer_lo',
                '    adc frame_counter+1',
                '    sta temp_ptr+1',
                '    lda (temp_ptr),y',
                '    sta $4006',
                '    ',
                '    ; Get and write timer high',
                '    lda #<pulse2_timer_hi',
                '    clc',
                '    adc frame_counter',
                '    sta temp_ptr',
                '    lda #>pulse2_timer_hi',
                '    adc frame_counter+1',
                '    sta temp_ptr+1',
                '    lda (temp_ptr),y',
                '    ora #$08',
                '    sta $4007',
                '    rts',
                '    ',
                '@silence:',
                '    lda #$30',
                '    sta $4004',
                '    rts',
                '    ',
                '@sustain:',
                '    rts',
                '.endproc',
                ''
            ])

        if 'triangle' in all_channels:
            lines.extend([
                '.proc play_triangle',
                '    ; Get note number for this frame',
                '    lda #<triangle_note',
                '    clc',
                '    adc frame_counter',
                '    sta temp_ptr',
                '    lda #>triangle_note',
                '    adc frame_counter+1',
                '    sta temp_ptr+1',
                '    ldy #0',
                '    lda (temp_ptr),y',
                '    ',
                '    ; Check if note changed',
                '    cmp last_triangle_note',
                '    beq @sustain',
                '    sta last_triangle_note',
                '    ',
                '    ; Note changed - check if silence',
                '    beq @silence',
                '    ',
                '    ; New note - write full channel state',
                '    ; Get and write control byte',
                '    lda #<triangle_control',
                '    clc',
                '    adc frame_counter',
                '    sta temp_ptr',
                '    lda #>triangle_control',
                '    adc frame_counter+1',
                '    sta temp_ptr+1',
                '    lda (temp_ptr),y',
                '    sta $4008',
                '    ',
                '    ; Get and write timer low',
                '    lda #<triangle_timer_lo',
                '    clc',
                '    adc frame_counter',
                '    sta temp_ptr',
                '    lda #>triangle_timer_lo',
                '    adc frame_counter+1',
                '    sta temp_ptr+1',
                '    lda (temp_ptr),y',
                '    sta $400A',
                '    ',
                '    ; Get and write timer high',
                '    lda #<triangle_timer_hi',
                '    clc',
                '    adc frame_counter',
                '    sta temp_ptr',
                '    lda #>triangle_timer_hi',
                '    adc frame_counter+1',
                '    sta temp_ptr+1',
                '    lda (temp_ptr),y',
                '    ora #$08',
                '    sta $400B',
                '    rts',
                '    ',
                '@silence:',
                '    lda #$00',
                '    sta $4008',
                '    rts',
                '    ',
                '@sustain:',
                '    rts',
                '.endproc',
                ''
            ])

        lines.extend([
            '.proc irq',
            '    rti',
            '.endproc'
        ])
        
        # Add project builder compatible functions if not standalone
        if not standalone:
            lines.extend([
                '',
                '; Project builder compatible functions',
                '.global init_music',
                '.global update_music',
                '',
                'init_music:',
                '    ; Initialize APU for music playback',
                '    lda #$0F',
                '    sta $4015  ; Enable all channels',
                '    lda #$00',
                '    sta frame_counter',
                '    sta frame_counter+1',
                '    rts',
                '',
                'update_music:',
                '    ; Update music frame (called from NMI)',
                '    jsr play_music_frame',
                '    ',
                '    ; Increment frame counter',
                '    inc frame_counter',
                '    bne @no_carry',
                '    inc frame_counter+1',
                '@no_carry:',
                '    ',
                '    ; Check for song end and loop',
                f'    lda frame_counter+1',
                f'    cmp #>{max_frame}',
                f'    bcc @no_loop',
                f'    bne @loop_song',
                f'    lda frame_counter',
                f'    cmp #<{max_frame}',
                f'    bcc @no_loop',
                '@loop_song:',
                '    lda #$00',
                '    sta frame_counter',
                '    sta frame_counter+1',
                '@no_loop:',
                '    rts'
            ])
        
        # Add vectors if standalone
        if standalone:
            lines.append('')
            lines.append('.segment "VECTORS"')
            lines.append('    .word nmi')
            lines.append('    .word reset')
            lines.append('    .word irq')

        # Write assembly file
        with open(output_path, 'w') as f:
            f.write('\n'.join(lines))

        # Calculate total data size (4 tables per channel: note, control, timer_lo, timer_hi)
        total_bytes = (max_frame + 1) * 4 * len(all_channels)
        print(f"âœ… Table-based export complete: {output_path}")
        print(f"   Data size: {total_bytes:,} bytes ({total_bytes/1024:.1f} KB)")
        print(f"   Channels exported: {', '.join(all_channels.keys())}")

        return output_path

    def export_tables_with_patterns(self, frames, patterns, references, output_path, standalone=True):
        """Export with pattern compression - FIXED VERSION"""
        
        # If no patterns provided, use direct frame export but convert frames format first
        if not patterns or not references:
            print("âš ï¸  No patterns provided, using direct frame export")
            # Convert list format to dict format if needed
            if isinstance(frames, list):
                frame_dict = {}
                for frame_num, frame_data in enumerate(frames):
                    for channel_name, channel_data in frame_data.items():
                        if channel_name not in frame_dict:
                            frame_dict[channel_name] = {}
                        if channel_data['note'] > 0 or channel_data['volume'] > 0:
                            frame_dict[channel_name][str(frame_num)] = channel_data
                frames = frame_dict
            return self.export_direct_frames(frames, output_path, standalone)
        
        print("ðŸ”§ CA65 Exporter: Pattern compression mode")
        
        lines = []
        lines.append("; CA65 Assembly Export (Pattern Compressed)")
        lines.append("; Generated by MIDI2NES - Fixed Exporter")
        lines.append("")
        
        # Add header segment if standalone
        if standalone:
            lines.append('.segment "HEADER"')
            lines.append('    .byte "NES", $1A')
            lines.append('    .byte $02        ; 32K PRG ROM')
            lines.append('    .byte $00        ; No CHR ROM')
            lines.append('    .byte $00        ; Mapper 0')
            lines.append('    .byte $00        ; System type')
            lines.append('')
        
        # Import/export zeropage variables for non-standalone
        if not standalone:
            lines.append('.importzp ptr1, temp1, temp2, frame_counter')
            lines.append('')
        
        # Pattern data goes in RODATA
        lines.append('.segment "RODATA"')
        lines.append('')
        
        # Add note table
        lines.append("note_table:")
        for i, note_val in enumerate(NOTE_TABLE_NTSC[:48]):  # First 4 octaves
            lines.append(f"    .word {note_val}  ; Note {i}")
        lines.append("")
        
        # Add REAL pattern data using the patterns and frames
        lines.append("; Pattern Data")
        
        for pattern_id, pattern in patterns.items():
            lines.append(f"{pattern_id}:")
            
            # Use the actual pattern events from the patterns structure
            events = pattern.get('events', [])
            print(f"  Pattern {pattern_id}: {len(events)} events")
            
            for event in events:
                if 'note' in event and event['note'] > 0:
                    # Use the actual note and volume from the pattern
                    timer_val = self.midi_note_to_timer_value(event['note'])
                    volume = min(15, max(0, event.get('volume', 8)))
                    
                    # Generate proper APU data bytes
                    control_byte = 0x80 | volume  # 50% duty + constant volume + volume level
                    lines.append(f"    .byte ${control_byte:02X}, ${timer_val & 0xFF:02X}, ${(timer_val >> 8) & 0x07:02X}")
                else:
                    # Silent frame
                    lines.append("    .byte $00, $00, $00")
            
            # End pattern marker
            lines.append("    .byte $FF  ; End of pattern")
            lines.append("")
        
        # Build frame-to-pattern mapping from pattern references
        frame_to_pattern = {}
        max_frame = 0
        
        if references:
            # Handle both formats
            first_key, first_value = next(iter(references.items()))
            
            if isinstance(first_value, list):
                # New format: pattern_id -> [frame_list]
                for pattern_id, frame_list in references.items():
                    for i, frame_num in enumerate(frame_list):
                        frame_to_pattern[frame_num] = (pattern_id, i)
                        max_frame = max(max_frame, frame_num)
            else:
                # Old format: frame_str -> (pattern_id, offset)
                for frame_str, pattern_info in references.items():
                    frame_num = int(frame_str)
                    pattern_id, offset = pattern_info
                    frame_to_pattern[frame_num] = (pattern_id, offset)
                    max_frame = max(max_frame, frame_num)
        
        # Export pattern reference table
        lines.append("; Pattern Reference Table")
        lines.append("pattern_refs:")
        
        if not frame_to_pattern:
            lines.append("    .word 0, 0")
        else:
            for frame in range(max_frame + 1):
                if frame in frame_to_pattern:
                    pattern_id, offset = frame_to_pattern[frame]
                    lines.append(f"    .word {pattern_id}, {offset}")
                else:
                    lines.append("    .word 0, 0")
        lines.append("")
        
        # Add the music engine code (enhanced for pattern playback)
        lines.extend([
            "; Music Engine Code",
            '.segment "CODE"',
            "",
            ".global init_music",
            "init_music:",
            "    lda #$0F",
            "    sta $4015",
            "    lda #$30  ; APU channel setup",
            "    sta $4000",
            "    sta $4004", 
            "    sta $4008",
            "    sta $400C",
            "    rts",
            "",
            ".global update_music",
            "update_music:",
            "    jsr play_pattern_frame",
            "    inc frame_counter",
            "    bne @no_carry",
            "    inc frame_counter+1",
            "@no_carry:",
            "    rts",
            "",
            "play_pattern_frame:",
            "    ; Get pattern pointer and offset for current frame",
            "    lda frame_counter",
            "    asl",
            "    asl  ; multiply by 4 (2 words per frame)",
            "    tax",
            "    lda pattern_refs,x  ; Pattern pointer low",
            "    sta ptr1",
            "    lda pattern_refs+1,x  ; Pattern pointer high",
            "    sta ptr1+1",
            "    ; Check if pattern is valid (not $0000)",
            "    ora ptr1",
            "    beq @done",
            "    ; Get offset into pattern",
            "    inx",
            "    inx",
            "    lda pattern_refs,x  ; Offset low byte",
            "    sta temp1",
            "    ; Add offset to pattern pointer (ptr1 += temp1 * 3)",
            "    ; Each event is 3 bytes, so multiply offset by 3",
            "    asl temp1  ; temp1 * 2",
            "    clc",
            "    lda ptr1",
            "    adc temp1",
            "    sta ptr1",
            "    lda ptr1+1",
            "    adc #0",
            "    sta ptr1+1",
            "    ; Add temp1/2 again to get temp1*3",
            "    lsr temp1",
            "    clc",
            "    lda ptr1",
            "    adc temp1",
            "    sta ptr1",
            "    lda ptr1+1",
            "    adc #0",
            "    sta ptr1+1",
            "    ; Now ptr1 points to the correct event in the pattern",
            "    ; Read 3-byte event and play it",
            "    ldy #0",
            "    lda (ptr1),y  ; Control byte",
            "    cmp #$FF      ; Check for end marker",
            "    beq @done",
            "    beq @silence  ; If $00, silence channel",
            "    sta $4000     ; Pulse 1 control",
            "    iny",
            "    lda (ptr1),y  ; Timer low",
            "    sta $4002",
            "    iny",
            "    lda (ptr1),y  ; Timer high",
            "    and #$07      ; Mask to 3 bits",
            "    ora #$08      ; Set length counter load bit",
            "    sta $4003",
            "    rts",
            "@silence:",
            "    lda #$30      ; Silence (no envelope, volume 0)",
            "    sta $4000",
            "@done:",
            "    rts"
        ])
        
        # Add vectors if standalone
        if standalone:
            lines.append('')
            lines.append('.segment "VECTORS"')
            lines.append('    .word 0')
            lines.append('    .word init_music')
            lines.append('    .word 0')
        
        # Write to file
        with open(output_path, 'w') as f:
            f.write('\n'.join(lines))
        
        print(f"âœ… Pattern export complete: {output_path}")

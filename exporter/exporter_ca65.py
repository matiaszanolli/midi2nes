import json
from pathlib import Path
from exporter.base_exporter import BaseExporter

# NES APU register addresses
APU_PULSE1_CTRL = 0x4000
APU_PULSE1_SWEEP = 0x4001
APU_PULSE1_TIMER_LO = 0x4002
APU_PULSE1_TIMER_HI = 0x4003

APU_PULSE2_CTRL = 0x4004
APU_PULSE2_SWEEP = 0x4005
APU_PULSE2_TIMER_LO = 0x4006
APU_PULSE2_TIMER_HI = 0x4007

APU_TRIANGLE_CTRL = 0x4008
APU_TRIANGLE_TIMER_LO = 0x400A
APU_TRIANGLE_TIMER_HI = 0x400B

APU_NOISE_CTRL = 0x400C
APU_NOISE_PERIOD = 0x400E
APU_NOISE_LENGTH = 0x400F

APU_DMC_CTRL = 0x4010
APU_DMC_LOAD = 0x4011
APU_DMC_ADDR = 0x4012
APU_DMC_LEN = 0x4013

APU_STATUS = 0x4015

# NES note frequency table (NTSC)
# These are timer values for the APU pulse/triangle channels
NOTE_TABLE_NTSC = [
    # C    C#   D    D#   E    F    F#   G    G#   A    A#   B
    1712, 1616, 1525, 1440, 1357, 1281, 1209, 1141, 1077, 1017, 961, 907,  # Octave 1
    856,  808,  762,  720,  678,  640,  604,  570,  538,  508,  480, 453,   # Octave 2
    428,  404,  381,  360,  339,  320,  302,  285,  269,  254,  240, 226,   # Octave 3
    214,  202,  190,  180,  170,  160,  151,  143,  135,  127,  120, 113,   # Octave 4
    107,  101,  95,   90,   85,   80,   76,   71,   67,   64,   60,  57,    # Octave 5
    53,   50,   48,   45,   42,   40,   38,   36,   34,   32,   30,  28,    # Octave 6
    27,   25,   24,   22,   21,   20,   19,   18,   17,   16,   15,  14,    # Octave 7
    13,   13,   12,   11,   11,   10,   9,    9,    8,    8,    7,   7      # Octave 8
]

# Noise period table
NOISE_PERIODS = [4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068]


class CA65Exporter(BaseExporter):
    def __init__(self):
        super().__init__()
        
    def export_tables_with_patterns(self, frames_data, patterns, references, output_path):
        lines = []
        lines.append("; CA65 Assembly Export (Pattern Compressed)")
        lines.append("; Generated by MIDI2NES")
        lines.append("")
        
        # Add compression metadata structures
        lines.extend([
            ".struct PatternMetadata",
            "    rle_count   .byte",
            "    delta_count .byte",
            "    data_size   .word",
            ".endstruct",
            ""
        ])
        
        # Compress and export each pattern
        for pattern_id, pattern in patterns.items():
            compressed, metadata = self.compress_channel_data(pattern['events'])
            
            # Add pattern metadata
            lines.append(f"pattern_{pattern_id}_metadata:")
            lines.append(f"    .byte {len(metadata['rle_blocks'])}  ; RLE block count")
            lines.append(f"    .byte {len(metadata['delta_blocks'])}  ; Delta block count")
            lines.append(f"    .word {len(compressed)}  ; Compressed data size")
            
            # Add compressed pattern data
            lines.append(f"pattern_{pattern_id}_data:")
            lines.append("    .byte " + ",".join(f"${b:02X}" for b in compressed))
            lines.append("")
        
        # Add decompression routine
        self._add_decompression_routine(lines)
        
        # Write to file
        with open(output_path, 'w') as f:
            f.write('\n'.join(lines))
    
    def _add_decompression_routine(self, lines):
        """Add assembly routine for decompressing pattern data"""
        lines.extend([
            "; Pattern Decompression Routine",
            ".proc decompress_pattern",
            "    ; Input:",
            "    ;   X,Y = pattern data pointer",
            "    ;   ptr1 = destination buffer",
            "",
            "    stx source",
            "    sty source+1",
            "",
            "    ; Read metadata",
            "    ldy #0",
            "    lda (source),y  ; RLE block count",
            "    sta rle_count",
            "    iny",
            "    lda (source),y  ; Delta block count",
            "    sta delta_count",
            "",
            "    ; Process blocks",
            "decompress_loop:",
            "    ldy #0",
            "    lda (source),y  ; Get block type",
            "    cmp #1",
            "    beq rle_block",
            "    cmp #2",
            "    beq delta_block",
            "",
            "    ; Regular event",
            "    jsr copy_event",
            "    jmp next_block",
            "",
            "rle_block:",
            "    jsr expand_rle",
            "    jmp next_block",
            "",
            "delta_block:",
            "    jsr expand_delta",
            "",
            "next_block:",
            "    ; Check if we're done",
            "    dec block_count",
            "    bne decompress_loop",
            "    rts",
            "",
            "; Variables",
            "source: .word 0",
            "rle_count: .byte 0",
            "delta_count: .byte 0",
            "block_count: .byte 0",
            ".endproc"
        ])

# Export the main function for backwards compatibility
def export_ca65_tables_with_patterns(frames, patterns, references, output_path):
    exporter = CA65Exporter()
    return exporter.export_tables_with_patterns(frames, patterns, references, output_path)
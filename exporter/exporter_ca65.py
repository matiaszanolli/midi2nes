import json
from pathlib import Path
from exporter.pattern_exporter import PatternExporter

# NES APU register addresses
APU_PULSE1_CTRL = 0x4000
APU_PULSE1_SWEEP = 0x4001
APU_PULSE1_TIMER_LO = 0x4002
APU_PULSE1_TIMER_HI = 0x4003

APU_PULSE2_CTRL = 0x4004
APU_PULSE2_SWEEP = 0x4005
APU_PULSE2_TIMER_LO = 0x4006
APU_PULSE2_TIMER_HI = 0x4007

APU_TRIANGLE_CTRL = 0x4008
APU_TRIANGLE_TIMER_LO = 0x400A
APU_TRIANGLE_TIMER_HI = 0x400B

APU_NOISE_CTRL = 0x400C
APU_NOISE_PERIOD = 0x400E
APU_NOISE_LENGTH = 0x400F

APU_DMC_CTRL = 0x4010
APU_DMC_LOAD = 0x4011
APU_DMC_ADDR = 0x4012
APU_DMC_LEN = 0x4013

APU_STATUS = 0x4015

# NES note frequency table (NTSC)
# These are timer values for the APU pulse/triangle channels
NOTE_TABLE_NTSC = [
    # C    C#   D    D#   E    F    F#   G    G#   A    A#   B
    1712, 1616, 1525, 1440, 1357, 1281, 1209, 1141, 1077, 1017, 961, 907,  # Octave 1
    856,  808,  762,  720,  678,  640,  604,  570,  538,  508,  480, 453,   # Octave 2
    428,  404,  381,  360,  339,  320,  302,  285,  269,  254,  240, 226,   # Octave 3
    214,  202,  190,  180,  170,  160,  151,  143,  135,  127,  120, 113,   # Octave 4
    107,  101,  95,   90,   85,   80,   76,   71,   67,   64,   60,  57,    # Octave 5
    53,   50,   48,   45,   42,   40,   38,   36,   34,   32,   30,  28,    # Octave 6
    27,   25,   24,   22,   21,   20,   19,   18,   17,   16,   15,  14,    # Octave 7
    13,   13,   12,   11,   11,   10,   9,    9,    8,    8,    7,   7      # Octave 8
]

# Noise period table
NOISE_PERIODS = [4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068]

def midi_note_to_timer_value(midi_note):
    """Convert MIDI note number to NES timer value"""
    if midi_note < 24 or midi_note > 119:  # Valid range for NES
        return 0
    return NOTE_TABLE_NTSC[midi_note - 24]

# exporter_ca65.py (modified version)

def export_ca65_tables_with_patterns(frames_data, compressed_patterns, pattern_refs, output_path):
    """Export frame data as CA65 assembly tables with pattern compression"""
    pattern_exporter = PatternExporter(compressed_patterns, pattern_refs)
    
    # Get the maximum frame number
    max_frame = pattern_exporter.get_max_frame()
    
    lines = []
    lines.append("; CA65 Assembly Export (Pattern Compressed)")
    lines.append("; Generated by MIDI2NES")
    lines.append("")
    lines.append(".segment \"RODATA\"")
    lines.append("")
    
    # Export pattern data
    lines.append("; Pattern Data")
    for pattern_id, pattern in compressed_patterns.items():
        lines.append(f"pattern_{pattern_id}:")
        for event in pattern['events']:
            # Convert event data to bytes
            if 'note' in event:
                timer_val = midi_note_to_timer_value(event['note'])
                volume = min(15, max(0, event['volume']))
                lines.append(f"    .byte ${volume:02X}, ${timer_val & 0xFF:02X}, ${(timer_val >> 8) & 0x07:02X}")
        lines.append("")
    
    # Export pattern reference table
    lines.append("; Pattern Reference Table")
    lines.append("pattern_refs:")
    for frame in range(max_frame + 1):
        if frame in pattern_exporter.pattern_map:
            pattern_id, offset = pattern_exporter.pattern_map[frame]
            lines.append(f"    .word pattern_{pattern_id}")
            lines.append(f"    .byte {offset}")
        else:
            lines.append("    .word 0")
            lines.append("    .byte 0")
    lines.append("")
    
    # Add the pattern playback routine
    lines.extend([
        "; Pattern Playback Routine",
        ".segment \"CODE\"",
        "",
        ".proc play_pattern_frame",
        "    ; Input: A = frame number",
        "    ; Preserves X, Y",
        "    asl",
        "    asl  ; Multiply by 4 (3 bytes per entry)",
        "    tax",
        "    ",
        "    ; Get pattern pointer and offset",
        "    lda pattern_refs,x",
        "    sta ptr",
        "    lda pattern_refs+1,x",
        "    sta ptr+1",
        "    lda pattern_refs+2,x",
        "    sta pattern_offset",
        "    ",
        "    ; Check if we have a pattern",
        "    lda ptr+1",
        "    ora ptr",
        "    beq silent_frame",
        "    ",
        "    ; Get pattern data",
        "    ldy pattern_offset",
        "    lda (ptr),y",
        "    sta volume",
        "    iny",
        "    lda (ptr),y",
        "    sta timer_lo",
        "    iny",
        "    lda (ptr),y",
        "    sta timer_hi",
        "    jmp play_frame",
        "    ",
        "silent_frame:",
        "    lda #$00",
        "    sta volume",
        "    sta timer_lo",
        "    sta timer_hi",
        "    ",
        "play_frame:",
        "    ; Play the frame data",
        "    lda volume",
        f"    sta ${APU_PULSE1_CTRL:04X}",
        "    lda timer_lo",
        f"    sta ${APU_PULSE1_TIMER_LO:04X}",
        "    lda timer_hi",
        f"    sta ${APU_PULSE1_TIMER_HI:04X}",
        "    rts",
        ".endproc",
        "",
        "; Variables",
        ".segment \"BSS\"",
        "ptr: .res 2",
        "pattern_offset: .res 1",
        "volume: .res 1",
        "timer_lo: .res 1",
        "timer_hi: .res 1"
    ])
    
    # Write to file
    with open(output_path, 'w') as f:
        f.write('\n'.join(lines))

import json
from pathlib import Path
from exporter.base_exporter import BaseExporter

# NES APU register addresses
APU_PULSE1_CTRL = 0x4000
APU_PULSE1_SWEEP = 0x4001
APU_PULSE1_TIMER_LO = 0x4002
APU_PULSE1_TIMER_HI = 0x4003

APU_PULSE2_CTRL = 0x4004
APU_PULSE2_SWEEP = 0x4005
APU_PULSE2_TIMER_LO = 0x4006
APU_PULSE2_TIMER_HI = 0x4007

APU_TRIANGLE_CTRL = 0x4008
APU_TRIANGLE_TIMER_LO = 0x400A
APU_TRIANGLE_TIMER_HI = 0x400B

APU_NOISE_CTRL = 0x400C
APU_NOISE_PERIOD = 0x400E
APU_NOISE_LENGTH = 0x400F

APU_DMC_CTRL = 0x4010
APU_DMC_LOAD = 0x4011
APU_DMC_ADDR = 0x4012
APU_DMC_LEN = 0x4013

APU_STATUS = 0x4015

# NES note frequency table (NTSC)
# These are timer values for the APU pulse/triangle channels
NOTE_TABLE_NTSC = [
    # C    C#   D    D#   E    F    F#   G    G#   A    A#   B
    1712, 1616, 1525, 1440, 1357, 1281, 1209, 1141, 1077, 1017, 961, 907,  # Octave 1
    856,  808,  762,  720,  678,  640,  604,  570,  538,  508,  480, 453,   # Octave 2
    428,  404,  381,  360,  339,  320,  302,  285,  269,  254,  240, 226,   # Octave 3
    214,  202,  190,  180,  170,  160,  151,  143,  135,  127,  120, 113,   # Octave 4
    107,  101,  95,   90,   85,   80,   76,   71,   67,   64,   60,  57,    # Octave 5
    53,   50,   48,   45,   42,   40,   38,   36,   34,   32,   30,  28,    # Octave 6
    27,   25,   24,   22,   21,   20,   19,   18,   17,   16,   15,  14,    # Octave 7
    13,   13,   12,   11,   11,   10,   9,    9,    8,    8,    7,   7      # Octave 8
]

# Noise period table
NOISE_PERIODS = [4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068]


class CA65Exporter(BaseExporter):
    def __init__(self):
        super().__init__()
        
def midi_note_to_timer_value(midi_note):
    if midi_note < 24 or midi_note > 119:  # Valid range for NES
        return 0
    return NOTE_TABLE_NTSC[midi_note - 24]

def export_ca65_tables_with_patterns(frames, patterns, references, output_path):
    lines = []
    lines.append("; CA65 Assembly Export (Pattern Compressed)")
    lines.append("; Generated by MIDI2NES")
    lines.append("")
    lines.append(".importzp ptr1, source, temp1, temp2")  # Import zero-page variables
    lines.append("")
    lines.append(".export init_music")
    lines.append(".export update_music")
    lines.append("")
    lines.append(".segment \"CODE\"")
    
    # Add music engine routines
    lines.extend([
        "init_music:",
        "    ; Initialize APU",
        "    lda #$0F",
        "    sta $4015   ; Enable all channels except DMC",
        "    lda #$30",
        "    sta $4000   ; Set up Pulse 1",
        "    sta $4004   ; Set up Pulse 2",
        "    sta $4008   ; Set up Triangle",
        "    lda #$00",
        "    sta $400C   ; Set up Noise",
        "    rts",
        "",
        "update_music:",
        "    ; Update frame",
        "    ; Your frame update logic here",
        "    rts",
        "",
        "; Pattern Data",
        ".segment \"RODATA\""
    ])
    
    # Add pattern data
    for pattern_id, pattern in patterns.items():
        lines.append(f"pattern_{pattern_id}:")
        for event in pattern['events']:
            if 'note' in event:
                timer_val = midi_note_to_timer_value(event['note'])
                volume = min(15, max(0, event['volume']))
                lines.append(f"    .byte ${volume:02X}, ${timer_val & 0xFF:02X}, ${(timer_val >> 8) & 0x07:02X}")
        lines.append("")
    
    # Write to file
    with open(output_path, 'w') as f:
        f.write('\n'.join(lines))
    
    def _add_decompression_routine(self, lines):
        """Add assembly routine for decompressing pattern data"""
        lines.extend([
            "; Pattern Decompression Routine",
            ".proc decompress_pattern",
            "    ; Input:",
            "    ;   X,Y = pattern data pointer",
            "    ;   ptr1 = destination buffer",
            "",
            "    stx source",
            "    sty source+1",
            "",
            "    ; Read metadata",
            "    ldy #0",
            "    lda (source),y  ; RLE block count",
            "    sta rle_count",
            "    iny",
            "    lda (source),y  ; Delta block count",
            "    sta delta_count",
            "",
            "    ; Process blocks",
            "decompress_loop:",
            "    ldy #0",
            "    lda (source),y  ; Get block type",
            "    cmp #1",
            "    beq rle_block",
            "    cmp #2",
            "    beq delta_block",
            "",
            "    ; Regular event",
            "    jsr copy_event",
            "    jmp next_block",
            "",
            "rle_block:",
            "    jsr expand_rle",
            "    jmp next_block",
            "",
            "delta_block:",
            "    jsr expand_delta",
            "",
            "next_block:",
            "    ; Check if we're done",
            "    dec block_count",
            "    bne decompress_loop",
            "    rts",
            "",
            "; Variables",
            "source: .word 0",
            "rle_count: .byte 0",
            "delta_count: .byte 0",
            "block_count: .byte 0",
            ".endproc"
        ])

def export_ca65_tables_with_patterns(frames, patterns, references, output_path):
    lines = []
    lines.append("; CA65 Assembly Export (Pattern Compressed)")
    lines.append("; Generated by MIDI2NES")
    lines.append("")
    lines.append(".importzp ptr1, source, temp1, temp2")  # Import zero-page variables
    lines.append("")
    lines.append(".export init_music")
    lines.append(".export update_music")
    lines.append("")
    lines.append(".segment \"CODE\"")
    
    # Add music engine routines
    lines.extend([
        "init_music:",
        "    ; Initialize APU",
        "    lda #$0F",
        "    sta $4015   ; Enable all channels except DMC",
        "    lda #$30",
        "    sta $4000   ; Set up Pulse 1",
        "    sta $4004   ; Set up Pulse 2",
        "    sta $4008   ; Set up Triangle",
        "    lda #$00",
        "    sta $400C   ; Set up Noise",
        "    rts",
        "",
        "update_music:",
        "    ; Update frame",
        "    ; Your frame update logic here",
        "    rts",
        "",
        "; Pattern Data",
        ".segment \"RODATA\""
    ])
    
    # Add pattern data
    for pattern_id, pattern in patterns.items():
        lines.append(f"pattern_{pattern_id}:")
        for event in pattern['events']:
            if 'note' in event:
                timer_val = midi_note_to_timer_value(event['note'])
                volume = min(15, max(0, event['volume']))
                lines.append(f"    .byte ${volume:02X}, ${timer_val & 0xFF:02X}, ${(timer_val >> 8) & 0x07:02X}")
        lines.append("")
    
    # Write to file
    with open(output_path, 'w') as f:
        f.write('\n'.join(lines))

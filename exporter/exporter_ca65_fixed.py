import json
from pathlib import Path
from exporter.base_exporter import BaseExporter

# NES APU register addresses
APU_PULSE1_CTRL = 0x4000
APU_PULSE1_SWEEP = 0x4001
APU_PULSE1_TIMER_LO = 0x4002
APU_PULSE1_TIMER_HI = 0x4003

APU_PULSE2_CTRL = 0x4004
APU_PULSE2_SWEEP = 0x4005
APU_PULSE2_TIMER_LO = 0x4006
APU_PULSE2_TIMER_HI = 0x4007

APU_TRIANGLE_CTRL = 0x4008
APU_TRIANGLE_TIMER_LO = 0x400A
APU_TRIANGLE_TIMER_HI = 0x400B

APU_NOISE_CTRL = 0x400C
APU_NOISE_PERIOD = 0x400E
APU_NOISE_LENGTH = 0x400F

APU_DMC_CTRL = 0x4010
APU_DMC_LOAD = 0x4011
APU_DMC_ADDR = 0x4012
APU_DMC_LEN = 0x4013

APU_STATUS = 0x4015

# NES note frequency table (NTSC)
# These are timer values for the APU pulse/triangle channels
NOTE_TABLE_NTSC = [
    # C    C#   D    D#   E    F    F#   G    G#   A    A#   B
    1712, 1616, 1525, 1440, 1357, 1281, 1209, 1141, 1077, 1017, 961, 907,  # Octave 1
    856,  808,  762,  720,  678,  640,  604,  570,  538,  508,  480, 453,   # Octave 2
    428,  404,  381,  360,  339,  320,  302,  285,  269,  254,  240, 226,   # Octave 3
    214,  202,  190,  180,  170,  160,  151,  143,  135,  127,  120, 113,   # Octave 4
    107,  101,  95,   90,   85,   80,   76,   71,   67,   64,   60,  57,    # Octave 5
    53,   50,   48,   45,   42,   40,   38,   36,   34,   32,   30,  28,    # Octave 6
    27,   25,   24,   22,   21,   20,   19,   18,   17,   16,   15,  14,    # Octave 7
    13,   13,   12,   11,   11,   10,   9,    9,    8,    8,    7,   7      # Octave 8
]

# Noise period table
NOISE_PERIODS = [4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068]


class CA65Exporter(BaseExporter):
    def __init__(self):
        super().__init__()
        
    def midi_note_to_timer_value(self, midi_note):
        if midi_note < 24 or midi_note > 119:  # Valid range for NES
            return 0
        return NOTE_TABLE_NTSC[midi_note - 24]

    def export_direct_frames(self, frames, output_path, standalone=True):
        """Export frames data directly without pattern compression"""
        print("ðŸ”§ CA65 Exporter: Direct frame export mode")
        
        lines = []
        lines.append("; CA65 Assembly Export (Direct Frame Data)")
        lines.append("; Generated by MIDI2NES - Fixed Exporter")
        lines.append("")
        
        # Add header segment if standalone
        if standalone:
            lines.append('.segment "HEADER"')
            lines.append('    .byte "NES", $1A')
            lines.append('    .byte $02        ; 32K PRG ROM')
            lines.append('    .byte $00        ; No CHR ROM')
            lines.append('    .byte $00        ; Mapper 0')
            lines.append('    .byte $00        ; System type')
            lines.append('')
        
        # Zero page variables
        lines.append('.segment "ZEROPAGE"')
        lines.append('frame_counter: .res 2')
        lines.append('')
        
        # Main code segment  
        lines.append('.segment "CODE"')
        lines.append('')
        
        # Get all channels and find maximum frame
        all_channels = {}
        max_frame = 0
        
        for channel_name, channel_data in frames.items():
            if channel_data:  # Skip empty channels
                all_channels[channel_name] = channel_data
                channel_max = max(int(f) for f in channel_data.keys())
                max_frame = max(max_frame, channel_max)
        
        print(f"  Channels: {list(all_channels.keys())}")
        print(f"  Max frame: {max_frame}")
        
        # Add reset routine
        lines.extend([
            '.proc reset',
            '    ; Standard NES initialization', 
            '    sei',
            '    cld',
            '    ldx #$FF',
            '    txs',
            '    ',
            '    ; PPU warmup',
            '    bit $2002',
            '@wait_vbl1:',
            '    bit $2002',
            '    bpl @wait_vbl1',
            '@wait_vbl2:',
            '    bit $2002', 
            '    bpl @wait_vbl2',
            '    ',
            '    ; APU initialization',
            '    lda #$00',
            '    sta $4015',
            '    lda #$40',
            '    sta $4017',
            '    lda #$0F',
            '    sta $4015',
            '    ',
            '    ; Initialize frame counter',
            '    lda #$00',
            '    sta frame_counter',
            '    sta frame_counter+1',
            '    ',
            '    ; Enable NMI',
            '    lda #$80',
            '    sta $2000',
            '    ',
            '@main_loop:',
            '    jmp @main_loop',
            '.endproc',
            '',
            '.proc nmi',
            '    ; Save registers',
            '    pha',
            '    txa',
            '    pha',
            '    tya',
            '    pha',
            '    ',
            '    ; Play current frame',
            '    jsr play_music_frame',
            '    ',
            '    ; Increment frame counter',
            '    inc frame_counter',
            '    bne @no_carry',
            '    inc frame_counter+1',
            '@no_carry:',
            '    ',
            '    ; Check for song end and loop',
            f'    lda frame_counter+1',
            f'    bne @loop_song',
            f'    lda frame_counter',
            f'    cmp #{max_frame + 10}',
            f'    bcc @done',
            '@loop_song:',
            '    lda #$00',
            '    sta frame_counter',
            '    sta frame_counter+1',
            '@done:',
            '    ; Restore registers',
            '    pla',
            '    tay',
            '    pla',
            '    tax',
            '    pla',
            '    rti',
            '.endproc',
            ''
        ])
        
        # Generate frame playback routine
        lines.append('.proc play_music_frame')
        
        # Add frame-by-frame playback for each channel
        for channel_name, channel_data in all_channels.items():
            if channel_name == 'pulse1':
                lines.append(f'    ; === {channel_name.upper()} CHANNEL ===')
                
                frame_count = 0
                for frame_str in sorted(channel_data.keys(), key=int):
                    if frame_count > 50:  # Limit for reasonable ROM size
                        break
                        
                    frame_num = int(frame_str)
                    frame_data = channel_data[frame_str]
                    
                    # Extract the actual values from our converted data
                    pitch = frame_data.get('pitch', 428)
                    control = frame_data.get('control', 152)
                    note = frame_data.get('note', 60)
                    volume = frame_data.get('volume', 8)
                    
                    lines.extend([
                        f'    ; Frame {frame_num} - {channel_name} Note {note}',
                        f'    lda frame_counter',
                        f'    cmp #{frame_num}',
                        f'    bne @skip_{channel_name}_{frame_count}',
                        f'    lda frame_counter+1',
                        f'    cmp #0',
                        f'    bne @skip_{channel_name}_{frame_count}',
                        f'    ',
                        f'    ; Set pulse1 registers',
                        f'    lda #{control}         ; Duty cycle + volume',
                        f'    sta $4000',
                        f'    lda #{pitch & 0xFF}    ; Timer low',
                        f'    sta $4002',
                        f'    lda #{((pitch >> 8) & 0x07) | 0x08}  ; Timer high + length reset',
                        f'    sta $4003',
                        f'@skip_{channel_name}_{frame_count}:'
                    ])
                    frame_count += 1
                    
            elif channel_name == 'pulse2':
                lines.append(f'    ; === {channel_name.upper()} CHANNEL ===')
                
                frame_count = 0
                for frame_str in sorted(channel_data.keys(), key=int):
                    if frame_count > 50:
                        break
                        
                    frame_num = int(frame_str)
                    frame_data = channel_data[frame_str]
                    
                    pitch = frame_data.get('pitch', 428)
                    control = frame_data.get('control', 152)
                    
                    lines.extend([
                        f'    ; Frame {frame_num} - {channel_name}',
                        f'    lda frame_counter',
                        f'    cmp #{frame_num}',
                        f'    bne @skip_{channel_name}_{frame_count}',
                        f'    lda frame_counter+1',
                        f'    cmp #0',
                        f'    bne @skip_{channel_name}_{frame_count}',
                        f'    ',
                        f'    ; Set pulse2 registers',
                        f'    lda #{control}',
                        f'    sta $4004',
                        f'    lda #{pitch & 0xFF}',
                        f'    sta $4006',
                        f'    lda #{((pitch >> 8) & 0x07) | 0x08}',
                        f'    sta $4007',
                        f'@skip_{channel_name}_{frame_count}:'
                    ])
                    frame_count += 1
                    
            elif channel_name == 'triangle':
                lines.append(f'    ; === {channel_name.upper()} CHANNEL ===')
                
                frame_count = 0
                for frame_str in sorted(channel_data.keys(), key=int):
                    if frame_count > 50:
                        break
                        
                    frame_num = int(frame_str)
                    frame_data = channel_data[frame_str]
                    
                    pitch = frame_data.get('pitch', 428)
                    control = frame_data.get('control', 128)
                    
                    lines.extend([
                        f'    ; Frame {frame_num} - {channel_name}',
                        f'    lda frame_counter',
                        f'    cmp #{frame_num}',
                        f'    bne @skip_{channel_name}_{frame_count}',
                        f'    lda frame_counter+1',
                        f'    cmp #0',
                        f'    bne @skip_{channel_name}_{frame_count}',
                        f'    ',
                        f'    ; Set triangle registers',
                        f'    lda #{control}',
                        f'    sta $4008',
                        f'    lda #{pitch & 0xFF}',
                        f'    sta $400A', 
                        f'    lda #{((pitch >> 8) & 0x07) | 0x08}',
                        f'    sta $400B',
                        f'@skip_{channel_name}_{frame_count}:'
                    ])
                    frame_count += 1
        
        lines.extend([
            '    rts',
            '.endproc',
            '',
            '.proc irq',
            '    rti',
            '.endproc'
        ])
        
        # Add vectors if standalone
        if standalone:
            lines.append('')
            lines.append('.segment "VECTORS"')
            lines.append('    .word nmi')
            lines.append('    .word reset')
            lines.append('    .word irq')
        
        # Write assembly file
        with open(output_path, 'w') as f:
            f.write('\n'.join(lines))
        
        print(f"âœ… Direct frame export complete: {output_path}")

    def export_tables_with_patterns(self, frames, patterns, references, output_path, standalone=True):
        """Export with pattern compression - FIXED VERSION"""
        
        # If no patterns provided, use direct frame export
        if not patterns or not references:
            print("âš ï¸  No patterns provided, using direct frame export")
            return self.export_direct_frames(frames, output_path, standalone)
        
        print("ðŸ”§ CA65 Exporter: Pattern compression mode")
        
        lines = []
        lines.append("; CA65 Assembly Export (Pattern Compressed)")
        lines.append("; Generated by MIDI2NES - Fixed Exporter")
        lines.append("")
        
        # Add header segment if standalone
        if standalone:
            lines.append('.segment "HEADER"')
            lines.append('    .byte "NES", $1A')
            lines.append('    .byte $02        ; 32K PRG ROM')
            lines.append('    .byte $00        ; No CHR ROM')
            lines.append('    .byte $00        ; Mapper 0')
            lines.append('    .byte $00        ; System type')
            lines.append('')
        
        # Pattern data goes in RODATA
        lines.append('.segment "RODATA"')
        lines.append('')
        
        # Add note table
        lines.append("note_table:")
        for i, note_val in enumerate(NOTE_TABLE_NTSC[:48]):  # First 4 octaves
            lines.append(f"    .word {note_val}  ; Note {i}")
        lines.append("")
        
        # Add REAL pattern data using the patterns and frames
        lines.append("; Pattern Data")
        
        for pattern_id, pattern in patterns.items():
            lines.append(f"{pattern_id}:")
            
            # Use the actual pattern events from the patterns structure
            events = pattern.get('events', [])
            print(f"  Pattern {pattern_id}: {len(events)} events")
            
            for event in events:
                if 'note' in event and event['note'] > 0:
                    # Use the actual note and volume from the pattern
                    timer_val = self.midi_note_to_timer_value(event['note'])
                    volume = min(15, max(0, event.get('volume', 8)))
                    
                    # Generate proper APU data bytes
                    control_byte = 0x80 | volume  # 50% duty + constant volume + volume level
                    lines.append(f"    .byte ${control_byte:02X}, ${timer_val & 0xFF:02X}, ${(timer_val >> 8) & 0x07:02X}")
                else:
                    # Silent frame
                    lines.append("    .byte $00, $00, $00")
            
            # End pattern marker
            lines.append("    .byte $FF  ; End of pattern")
            lines.append("")
        
        # Build frame-to-pattern mapping from pattern references
        frame_to_pattern = {}
        max_frame = 0
        
        if references:
            # Handle both formats
            first_key, first_value = next(iter(references.items()))
            
            if isinstance(first_value, list):
                # New format: pattern_id -> [frame_list]
                for pattern_id, frame_list in references.items():
                    for i, frame_num in enumerate(frame_list):
                        frame_to_pattern[frame_num] = (pattern_id, i)
                        max_frame = max(max_frame, frame_num)
            else:
                # Old format: frame_str -> (pattern_id, offset)
                for frame_str, pattern_info in references.items():
                    frame_num = int(frame_str)
                    pattern_id, offset = pattern_info
                    frame_to_pattern[frame_num] = (pattern_id, offset)
                    max_frame = max(max_frame, frame_num)
        
        # Export pattern reference table
        lines.append("; Pattern Reference Table")
        lines.append("pattern_refs:")
        
        if not frame_to_pattern:
            lines.append("    .word 0, 0")
        else:
            for frame in range(max_frame + 1):
                if frame in frame_to_pattern:
                    pattern_id, offset = frame_to_pattern[frame]
                    lines.append(f"    .word {pattern_id}, {offset}")
                else:
                    lines.append("    .word 0, 0")
        lines.append("")
        
        # Add the music engine code (simplified for pattern playback)
        lines.extend([
            "; Music Engine Code",
            '.segment "CODE"',
            "",
            ".global init_music",
            "init_music:",
            "    lda #$0F",
            "    sta $4015",
            "    rts",
            "",
            ".global update_music",
            "update_music:",
            "    ; Pattern-based playback would go here",
            "    ; For now, this is a placeholder",
            "    rts"
        ])
        
        # Add vectors if standalone
        if standalone:
            lines.append('')
            lines.append('.segment "VECTORS"')
            lines.append('    .word 0')
            lines.append('    .word init_music')
            lines.append('    .word 0')
        
        # Write to file
        with open(output_path, 'w') as f:
            f.write('\n'.join(lines))
        
        print(f"âœ… Pattern export complete: {output_path}")

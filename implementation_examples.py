# Example 3: Enhanced tempo handling in parser.py

def parse_midi_with_tempo_changes(midi_path):
    """
    Enhanced MIDI parsing with improved tempo change handling.
    
    Args:
        midi_path: Path to MIDI file
        
    Returns:
        Dictionary of parsed events with accurate timing
    """
    import mido
    from collections import defaultdict
    
    FRAME_RATE_HZ = 60
    FRAME_MS = 1000 / FRAME_RATE_HZ
    
    mid = mido.MidiFile(midi_path)
    ticks_per_beat = mid.ticks_per_beat
    
    # Track tempo changes with timestamps
    tempo_changes = [(0, 500000)]  # (tick, tempo in microseconds per beat)
    
    # First pass: collect all tempo changes
    for track in mid.tracks:
        current_tick = 0
        for msg in track:
            current_tick += msg.time
            if msg.type == 'set_tempo':
                tempo_changes.append((current_tick, msg.tempo))
    
    # Sort tempo changes by tick
    tempo_changes.sort(key=lambda x: x[0])
    
    # Dict of {track_name: [events]}
    track_events = defaultdict(list)
    
    # Second pass: process events with accurate timing
    for i, track in enumerate(mid.tracks):
        current_tick = 0
        current_time_ms = 0
        
        track_name = f"track_{i}"
        
        for msg in track:
            current_tick += msg.time
            
            # Calculate time based on tempo changes
            current_time_ms = calculate_time_with_tempo_changes(
                current_tick, tempo_changes, ticks_per_beat)
            
            frame = int(current_time_ms / FRAME_MS)
            
            if msg.type == 'track_name':
                track_name = msg.name.strip().replace(" ", "_")
                
            elif msg.type == 'note_on' or msg.type == 'note_off':
                note = msg.note
                velocity = msg.velocity if msg.type == 'note_on' else 0
                
                # Ignore note_on with velocity 0 (acts as note_off)
                if msg.type == 'note_on' and velocity == 0:
                    msg_type = 'note_off'
                    velocity = 0
                else:
                    msg_type = msg.type
                
                track_events[track_name].append({
                    "frame": frame,
                    "note": note,
                    "volume": velocity,
                    "type": msg_type,
                    "tempo": get_current_tempo(current_tick, tempo_changes)
                })
    
    return track_events

def calculate_time_with_tempo_changes(tick, tempo_changes, ticks_per_beat):
    """
    Calculate time in milliseconds with tempo changes.
    
    Args:
        tick: Current tick
        tempo_changes: List of (tick, tempo) tuples
        ticks_per_beat: MIDI file ticks per beat
        
    Returns:
        Time in milliseconds
    """
    time_ms = 0
    prev_tick = 0
    prev_tempo = tempo_changes[0][1]
    
    for change_tick, tempo in tempo_changes:
        if change_tick >= tick:
            break
            
        # Calculate time for segment with previous tempo
        tick_diff = change_tick - prev_tick
        time_ms += (tick_diff * prev_tempo) / (ticks_per_beat * 1000)
        
        prev_tick = change_tick
        prev_tempo = tempo
    
    # Calculate remaining time with current tempo
    remaining_ticks = tick - prev_tick
    time_ms += (remaining_ticks * prev_tempo) / (ticks_per_beat * 1000)
    
    return time_ms

def get_current_tempo(tick, tempo_changes):
    """
    Get tempo at a specific tick.
    
    Args:
        tick: Current tick
        tempo_changes: List of (tick, tempo) tuples
        
    Returns:
        Current tempo in microseconds per beat
    """
    current_tempo = tempo_changes[0][1]
    
    for change_tick, tempo in tempo_changes:
        if change_tick > tick:
            break
        current_tempo = tempo
    
    return current_tempo


# Example 4: Multi-song support in exporter_ca65.py

def export_ca65_with_segments(frames_data, output_path, segments=None):
    """
    Export frame data as CA65 assembly with support for multiple song segments.
    
    Args:
        frames_data: Dictionary of frame data
        output_path: Output file path
        segments: Dictionary of segment definitions
    """
    if segments is None:
        segments = {
            "main": {
                "start_frame": 0,
                "end_frame": max(int(f) for ch in frames_data.values() for f in ch.keys()),
                "loop_to": 0
            }
        }
    
    lines = []
    lines.append("; CA65 Assembly Export")
    lines.append("; Generated by MIDI2NES")
    lines.append("")
    lines.append(".segment \"RODATA\"")
    lines.append("")
    
    # Export segment table
    lines.append("; Song segment table")
    lines.append("song_segment_table:")
    for i, (name, segment) in enumerate(segments.items()):
        lines.append(f"    .word segment_{i}_start  ; {name}")
    lines.append("")
    
    # Export segment loop table
    lines.append("; Song segment loop points")
    lines.append("song_segment_loop_table:")
    for i, (name, segment) in enumerate(segments.items()):
        loop_to = segment.get("loop_to", segment["start_frame"])
        lines.append(f"    .word {loop_to}  ; {name}")
    lines.append("")
    
    # Export segment lengths
    lines.append("; Song segment lengths (in frames)")
    lines.append("song_segment_length_table:")
    for i, (name, segment) in enumerate(segments.items()):
        length = segment["end_frame"] - segment["start_frame"] + 1
        lines.append(f"    .word {length}  ; {name}")
    lines.append("")
    
    # Export each segment's data
    for i, (name, segment) in enumerate(segments.items()):
        start_frame = segment["start_frame"]
        end_frame = segment["end_frame"]
        
        lines.append(f"; Segment {i}: {name}")
        lines.append(f"segment_{i}_start:")
        
        # Export pulse channel data
        for pulse_num in [1, 2]:
            channel_name = f"pulse{pulse_num}"
            if channel_name in frames_data:
                lines.append(f"; Pulse {pulse_num} Channel Data")
                lines.append(f"segment_{i}_{channel_name}:")
                
                for frame in range(start_frame, end_frame + 1):
                    frame_str = str(frame)
                    if frame_str in frames_data[channel_name]:
                        data = frames_data[channel_name][frame_str]
                        # Generate control bytes with envelope and duty cycle
                        # ... implementation details ...
                        lines.append(f"    .byte $XX, $XX, $XX  ; Frame {frame}")
                    else:
                        lines.append(f"    .byte $00, $00, $00  ; Frame {frame} (silent)")
                lines.append("")
        
        # Export triangle, noise, and DPCM channels similarly
        # ... implementation details ...
    
    # Export music player routine with segment support
    lines.extend([
        "; Music Player Routine with segment support",
        ".segment \"CODE\"",
        "",
        ".proc play_music_frame",
        "    ; Input: A = frame number (low byte), X = frame number (high byte)",
        "    ;        Y = segment number",
        "    ; Destroys: A, X, Y",
        "",
        "    ; Store parameters",
        "    sta temp_frame_lo",
        "    stx temp_frame_hi",
        "    sty temp_segment",
        "",
        "    ; Calculate segment offset",
        "    tya",
        "    asl",
        "    tax",
        "    lda song_segment_table,x",
        "    sta temp_segment_ptr",
        "    lda song_segment_table+1,x",
        "    sta temp_segment_ptr+1",
        "",
        "    ; Play channels",
        "    ; ... implementation details ...",
        "",
        "    rts",
        ".endproc",
        "",
        "; Variables",
        ".segment \"BSS\"",
        "temp_frame_lo: .res 1",
        "temp_frame_hi: .res 1",
        "temp_segment: .res 1",
        "temp_segment_ptr: .res 2",
        "current_frame: .res 2",
        "current_segment: .res 1",
        ""
    ])
    
    # Write to file
    with open(output_path, 'w') as f:
        f.write('\n'.join(lines))
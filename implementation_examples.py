from nes.song_bank import SongBank
import mido
from collections import defaultdict
from pathlib import Path

def parse_midi_with_tempo_changes(midi_path):
    """
    Enhanced MIDI parsing with improved tempo change handling.
    
    Args:
        midi_path: Path to MIDI file
        
    Returns:
        Dictionary of parsed events with accurate timing
    """
    
    FRAME_RATE_HZ = 60
    FRAME_MS = 1000 / FRAME_RATE_HZ
    
    mid = mido.MidiFile(midi_path)
    ticks_per_beat = mid.ticks_per_beat
    
    # Track tempo changes with timestamps
    tempo_changes = [(0, 500000)]  # (tick, tempo in microseconds per beat)
    
    # First pass: collect all tempo changes
    for track in mid.tracks:
        current_tick = 0
        for msg in track:
            current_tick += msg.time
            if msg.type == 'set_tempo':
                tempo_changes.append((current_tick, msg.tempo))
    
    # Sort tempo changes by tick
    tempo_changes.sort(key=lambda x: x[0])
    
    # Dict of {track_name: [events]}
    track_events = defaultdict(list)
    
    # Second pass: process events with accurate timing
    for i, track in enumerate(mid.tracks):
        current_tick = 0
        current_time_ms = 0
        
        track_name = f"track_{i}"
        
        for msg in track:
            current_tick += msg.time
            
            # Calculate time based on tempo changes
            current_time_ms = calculate_time_with_tempo_changes(
                current_tick, tempo_changes, ticks_per_beat)
            
            frame = int(current_time_ms / FRAME_MS)
            
            if msg.type == 'track_name':
                track_name = msg.name.strip().replace(" ", "_")
                
            elif msg.type == 'note_on' or msg.type == 'note_off':
                note = msg.note
                velocity = msg.velocity if msg.type == 'note_on' else 0
                
                # Ignore note_on with velocity 0 (acts as note_off)
                if msg.type == 'note_on' and velocity == 0:
                    msg_type = 'note_off'
                    velocity = 0
                else:
                    msg_type = msg.type
                
                track_events[track_name].append({
                    "frame": frame,
                    "note": note,
                    "volume": velocity,
                    "type": msg_type,
                    "tempo": get_current_tempo(current_tick, tempo_changes)
                })
    
    return track_events

def calculate_time_with_tempo_changes(tick, tempo_changes, ticks_per_beat):
    """
    Calculate time in milliseconds with tempo changes.
    
    Args:
        tick: Current tick
        tempo_changes: List of (tick, tempo) tuples
        ticks_per_beat: MIDI file ticks per beat
        
    Returns:
        Time in milliseconds
    """
    time_ms = 0
    prev_tick = 0
    prev_tempo = tempo_changes[0][1]
    
    for change_tick, tempo in tempo_changes:
        if change_tick >= tick:
            break
            
        # Calculate time for segment with previous tempo
        tick_diff = change_tick - prev_tick
        time_ms += (tick_diff * prev_tempo) / (ticks_per_beat * 1000)
        
        prev_tick = change_tick
        prev_tempo = tempo
    
    # Calculate remaining time with current tempo
    remaining_ticks = tick - prev_tick
    time_ms += (remaining_ticks * prev_tempo) / (ticks_per_beat * 1000)
    
    return time_ms

def get_current_tempo(tick, tempo_changes):
    """
    Get tempo at a specific tick.
    
    Args:
        tick: Current tick
        tempo_changes: List of (tick, tempo) tuples
        
    Returns:
        Current tempo in microseconds per beat
    """
    current_tempo = tempo_changes[0][1]
    
    for change_tick, tempo in tempo_changes:
        if change_tick > tick:
            break
        current_tempo = tempo
    
    return current_tempo


def export_ca65_with_segments(frames_data, output_path, song_bank=None):
    """
    Export frame data as CA65 assembly with support for multiple song segments
    and bank switching.
    
    Args:
        frames_data: Dictionary of frame data (can be None if song_bank is provided)
        output_path: Output file path
        song_bank: Optional SongBank instance for multi-song support
    """
    lines = []
    lines.append("; CA65 Assembly Export")
    lines.append("; Generated by MIDI2NES")
    lines.append("")
    
    if song_bank is None:
        # Fallback to single song mode
        if frames_data is None:
            raise ValueError("Either frames_data or song_bank must be provided")
            
        # Create default segment for single song
        segments = {
            "main": {
                "start_frame": 0,
                "end_frame": max(int(f) for ch in frames_data.values() for f in ch.keys()),
                "loop_to": 0
            }
        }
        
        lines.append(".segment \"RODATA\"")
        lines.append("")
        
        # Export segment table
        lines.append("; Song segment table")
        lines.append("song_segment_table:")
        for i, (name, segment) in enumerate(segments.items()):
            lines.append(f"    .word segment_{i}_start  ; {name}")
        lines.append("")
        
        # Export segment loop table
        lines.append("; Song segment loop points")
        lines.append("song_segment_loop_table:")
        for i, (name, segment) in enumerate(segments.items()):
            loop_to = segment.get("loop_to", segment["start_frame"])
            lines.append(f"    .word {loop_to}  ; {name}")
        lines.append("")
        
        # Export segment lengths
        lines.append("; Song segment lengths (in frames)")
        lines.append("song_segment_length_table:")
        for i, (name, segment) in enumerate(segments.items()):
            length = segment["end_frame"] - segment["start_frame"] + 1
            lines.append(f"    .word {length}  ; {name}")
        lines.append("")
        
        # Export each segment's data
        for i, (name, segment) in enumerate(segments.items()):
            start_frame = segment["start_frame"]
            end_frame = segment["end_frame"]
            
            lines.append(f"; Segment {i}: {name}")
            lines.append(f"segment_{i}_start:")
            
            # Export pulse channel data
            for pulse_num in [1, 2]:
                channel_name = f"pulse{pulse_num}"
                if channel_name in frames_data:
                    lines.append(f"; Pulse {pulse_num} Channel Data")
                    lines.append(f"segment_{i}_{channel_name}:")
                    
                    for frame in range(start_frame, end_frame + 1):
                        frame_str = str(frame)
                        if frame_str in frames_data[channel_name]:
                            data = frames_data[channel_name][frame_str]
                            bytes_data = _convert_pulse_data(data)
                            bytes_str = ', '.join(f'${b:02X}' for b in bytes_data)
                            lines.append(f"    .byte {bytes_str}  ; Frame {frame}")
                        else:
                            lines.append(f"    .byte $00, $00, $00  ; Frame {frame} (silent)")
                    lines.append("")
            
            # Export triangle channel data
            if 'triangle' in frames_data:
                lines.append("; Triangle Channel Data")
                lines.append(f"segment_{i}_triangle:")
                for frame in range(start_frame, end_frame + 1):
                    frame_str = str(frame)
                    if frame_str in frames_data['triangle']:
                        data = frames_data['triangle'][frame_str]
                        bytes_data = _convert_triangle_data(data)
                        bytes_str = ', '.join(f'${b:02X}' for b in bytes_data)
                        lines.append(f"    .byte {bytes_str}  ; Frame {frame}")
                    else:
                        lines.append(f"    .byte $00, $00, $00  ; Frame {frame} (silent)")
                lines.append("")
            
            # Export noise channel data
            if 'noise' in frames_data:
                lines.append("; Noise Channel Data")
                lines.append(f"segment_{i}_noise:")
                for frame in range(start_frame, end_frame + 1):
                    frame_str = str(frame)
                    if frame_str in frames_data['noise']:
                        data = frames_data['noise'][frame_str]
                        bytes_data = _convert_noise_data(data)
                        bytes_str = ', '.join(f'${b:02X}' for b in bytes_data)
                        lines.append(f"    .byte {bytes_str}  ; Frame {frame}")
                    else:
                        lines.append(f"    .byte $00, $00  ; Frame {frame} (silent)")
                lines.append("")
        
        # Export single song player routine
        lines.extend([
            "; Music Player Routine",
            ".segment \"CODE\"",
            "",
            ".proc play_music_frame",
            "    ; Input: A = frame number (low byte), X = frame number (high byte)",
            "    ;        Y = segment number",
            "    ; Destroys: A, X, Y",
            "",
            "    ; Store parameters",
            "    sta temp_frame_lo",
            "    stx temp_frame_hi",
            "    sty temp_segment",
            "",
            "    ; Calculate segment offset",
            "    tya",
            "    asl",
            "    tax",
            "    lda song_segment_table,x",
            "    sta temp_segment_ptr",
            "    lda song_segment_table+1,x",
            "    sta temp_segment_ptr+1",
            "",
            "    ; Play channels",
            "    jsr update_pulse1",
            "    jsr update_pulse2",
            "    jsr update_triangle",
            "    jsr update_noise",
            "",
            "    rts",
            ".endproc",
            "",
            "; Variables",
            ".segment \"BSS\"",
            "temp_frame_lo: .res 1",
            "temp_frame_hi: .res 1",
            "temp_segment: .res 1",
            "temp_segment_ptr: .res 2",
            "current_frame: .res 2",
            "current_segment: .res 1",
            ""
        ])
        
    else:
        # Multi-song bank mode
        # Export bank definitions
        for bank_num in song_bank.get_banks():
            lines.append(f".segment \"BANK{bank_num}\"")
            
            # Song table for this bank
            lines.append(f"bank{bank_num}_song_table:")
            for song_name in song_bank.get_songs_in_bank(bank_num):
                song_data = song_bank.get_song_data(song_name)
                lines.append(f"    .word song_{song_name}_data  ; {song_data['metadata'].get('title', song_name)}")
            lines.append("")
            
            # Export each song in this bank
            for song_name in song_bank.get_songs_in_bank(bank_num):
                song_data = song_bank.get_song_data(song_name)
                
                lines.append(f"; Song: {song_data['metadata'].get('title', song_name)}")
                lines.append(f"song_{song_name}_data:")
                
                # Export segment table
                lines.append("    .word segment_table")
                lines.append("    .word segment_loop_table")
                lines.append("    .word segment_length_table")
                lines.append("")
                
                # Export segments
                for segment_name, segment in song_data['segments'].items():
                    lines.extend(_export_segment(segment_name, segment))
        
        # Add bank switching code
        lines.extend([
            ".segment \"CODE\"",
            "song_bank_switch:",
            "    ; Save registers",
            "    pha",
            "    txa",
            "    pha",
            "    ; Switch bank",
            "    lda current_song_bank",
            "    sta $8000  ; Bank switching address",
            "    ; Restore registers",
            "    pla",
            "    tax",
            "    pla",
            "    rts",
            "",
            "; Variables",
            "current_song_bank: .byte 0",
            "current_song: .byte 0",
            "current_segment: .byte 0"
        ])
    
    # Write to file
    with open(output_path, 'w') as f:
        f.write('\n'.join(lines))


def _export_segment(name, segment):
    """Helper function to export a single segment"""
    lines = []
    lines.append(f"; Segment: {name}")
    
    # Export segment header
    lines.append(f"segment_{name}:")
    lines.append(f"    .word {segment['start_frame']}  ; Start frame")
    lines.append(f"    .word {segment['end_frame']}    ; End frame")
    lines.append(f"    .word {segment.get('loop_to', segment['start_frame'])}  ; Loop point")
    
    # Export channel data
    for channel in ['pulse1', 'pulse2', 'triangle', 'noise']:
        if channel in segment:
            lines.extend(_export_channel_data(channel, segment[channel]))
    
    return lines


def _convert_pulse_data(frame_data):
    """
    Convert pulse channel frame data to NES format bytes
    
    Args:
        frame_data: Dictionary containing note, volume, and duty cycle info
        
    Returns:
        List of bytes for the frame
    """
    duty = frame_data.get('duty', 2)  # Default duty cycle is 2 (50%)
    volume = frame_data.get('volume', 0)
    pitch = frame_data.get('pitch', 0)
    
    # First byte: DDLC VVVV (Duty, Length Counter, Volume)
    # D = duty cycle (2 bits)
    # L = length counter halt (1 = sustain)
    # C = constant volume (1 = use volume directly)
    # V = volume/envelope (4 bits)
    control = (duty << 6) | 0x30 | (volume & 0x0F)
    
    # Second byte: PPPP PPPP (8 lower bits of period)
    period_lo = pitch & 0xFF
    
    # Third byte: ---- PPPP (4 upper bits of period)
    period_hi = (pitch >> 8) & 0x07
    
    return [control, period_lo, period_hi]


def _convert_triangle_data(frame_data):
    """
    Convert triangle channel frame data to NES format bytes
    
    Args:
        frame_data: Dictionary containing note and counter info
        
    Returns:
        List of bytes for the frame
    """
    pitch = frame_data.get('pitch', 0)
    active = frame_data.get('volume', 0) > 0
    
    # First byte: CRRR RRRR (Counter reload value)
    # C = counter reload flag
    # R = linear counter reload value
    control = 0x80 if active else 0x00
    
    # Second byte: PPPP PPPP (8 lower bits of period)
    period_lo = pitch & 0xFF
    
    # Third byte: ---- PPPP (4 upper bits of period)
    period_hi = (pitch >> 8) & 0x07
    
    return [control, period_lo, period_hi]


def _convert_noise_data(frame_data):
    """
    Convert noise channel frame data to NES format bytes
    
    Args:
        frame_data: Dictionary containing volume and noise mode info
        
    Returns:
        List of bytes for the frame
    """
    volume = frame_data.get('volume', 0)
    noise_mode = frame_data.get('noise_mode', 0)  # 0 = periodic noise, 1 = metallic noise
    period = frame_data.get('period', 0)  # 0-15 noise period value
    
    # First byte: --LC VVVV (Length counter, Constant volume, Volume)
    # L = length counter halt (1 = sustain)
    # C = constant volume (1 = use volume directly)
    # V = volume/envelope (4 bits)
    control = 0x30 | (volume & 0x0F)
    
    # Second byte: M--- PPPP (Mode, Period)
    # M = noise mode (0 = periodic, 1 = metallic)
    # P = noise period (0-15)
    params = ((noise_mode & 0x01) << 7) | (period & 0x0F)
    
    return [control, params]


def _export_channel_data(channel_name, data):
    """Helper function to export channel data"""
    lines = []
    lines.append(f"; {channel_name} channel data")
    lines.append(f"{channel_name}_data:")
    
    for frame, frame_data in sorted(data.items()):
        # Convert frame data to bytes
        if channel_name in ['pulse1', 'pulse2']:
            bytes_data = _convert_pulse_data(frame_data)
        elif channel_name == 'triangle':
            bytes_data = _convert_triangle_data(frame_data)
        else:  # noise
            bytes_data = _convert_noise_data(frame_data)
            
        lines.append(f"    .byte {', '.join(f'${b:02X}' for b in bytes_data)}  ; Frame {frame}")
    
    return lines

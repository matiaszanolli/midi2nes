import json
from pathlib import Path

# NES APU register addresses
APU_PULSE1_CTRL = 0x4000
APU_PULSE1_SWEEP = 0x4001
APU_PULSE1_TIMER_LO = 0x4002
APU_PULSE1_TIMER_HI = 0x4003

APU_PULSE2_CTRL = 0x4004
APU_PULSE2_SWEEP = 0x4005
APU_PULSE2_TIMER_LO = 0x4006
APU_PULSE2_TIMER_HI = 0x4007

APU_TRIANGLE_CTRL = 0x4008
APU_TRIANGLE_TIMER_LO = 0x400A
APU_TRIANGLE_TIMER_HI = 0x400B

APU_NOISE_CTRL = 0x400C
APU_NOISE_PERIOD = 0x400E
APU_NOISE_LENGTH = 0x400F

APU_DMC_CTRL = 0x4010
APU_DMC_LOAD = 0x4011
APU_DMC_ADDR = 0x4012
APU_DMC_LEN = 0x4013

APU_STATUS = 0x4015

# NES note frequency table (NTSC)
# These are timer values for the APU pulse/triangle channels
NOTE_TABLE_NTSC = [
    # C    C#   D    D#   E    F    F#   G    G#   A    A#   B
    1712, 1616, 1525, 1440, 1357, 1281, 1209, 1141, 1077, 1017, 961, 907,  # Octave 1
    856,  808,  762,  720,  678,  640,  604,  570,  538,  508,  480, 453,   # Octave 2
    428,  404,  381,  360,  339,  320,  302,  285,  269,  254,  240, 226,   # Octave 3
    214,  202,  190,  180,  170,  160,  151,  143,  135,  127,  120, 113,   # Octave 4
    107,  101,  95,   90,   85,   80,   76,   71,   67,   64,   60,  57,    # Octave 5
    53,   50,   48,   45,   42,   40,   38,   36,   34,   32,   30,  28,    # Octave 6
    27,   25,   24,   22,   21,   20,   19,   18,   17,   16,   15,  14,    # Octave 7
    13,   13,   12,   11,   11,   10,   9,    9,    8,    8,    7,   7      # Octave 8
]

# Noise period table
NOISE_PERIODS = [4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068]

def midi_note_to_timer_value(midi_note):
    """Convert MIDI note number to NES timer value"""
    if midi_note < 24 or midi_note > 119:  # Valid range for NES
        return 0
    return NOTE_TABLE_NTSC[midi_note - 24]

def export_ca65_tables(frames_data, output_path):
    """Export frame data as CA65 assembly tables"""
    
    # Collect all unique frames and sort them
    all_frames = set()
    for channel_data in frames_data.values():
        all_frames.update(int(f) for f in channel_data.keys())
    
    # If no frames, create minimal data with one silent frame
    if not all_frames:
        all_frames = {0}
    
    sorted_frames = sorted(all_frames)
    max_frame = max(sorted_frames)
    
    lines = []
    lines.append("; CA65 Assembly Export")
    lines.append("; Generated by MIDI2NES")
    lines.append("")
    lines.append(".segment \"RODATA\"")
    lines.append("")
    
    # Export frame count
    lines.append(f"music_frame_count = {max_frame + 1}")
    lines.append("")
    
    # Define all channel sections, even if empty
    channels = {
        'pulse1': {'bytes': 3, 'duty': 2},  # 50% duty cycle
        'pulse2': {'bytes': 3, 'duty': 2},
        'triangle': {'bytes': 3, 'duty': None},
        'noise': {'bytes': 2, 'duty': None}
    }
    
    for channel_name, config in channels.items():
        lines.append(f"; {channel_name.capitalize()} Channel Data")
        lines.append(f"{channel_name}_frames:")
        
        if channel_name in frames_data and frames_data[channel_name]:
            # Channel has data - export it
            for frame in range(max_frame + 1):
                frame_str = str(frame)
                if frame_str in frames_data[channel_name]:
                    data = frames_data[channel_name][frame_str]
                    
                    if channel_name.startswith('pulse'):
                        timer_val = midi_note_to_timer_value(data['note'])
                        volume = min(15, max(0, data['volume']))
                        ctrl_byte = (config['duty'] << 6) | volume
                        timer_lo = timer_val & 0xFF
                        timer_hi = (timer_val >> 8) & 0x07
                        lines.append(f"    .byte ${ctrl_byte:02X}, ${timer_lo:02X}, ${timer_hi:02X}  ; Frame {frame}")
                    
                    elif channel_name == 'triangle':
                        timer_val = midi_note_to_timer_value(data['note'])
                        ctrl_byte = 0x80 if data['volume'] > 0 else 0x00
                        timer_lo = timer_val & 0xFF
                        timer_hi = (timer_val >> 8) & 0x07
                        lines.append(f"    .byte ${ctrl_byte:02X}, ${timer_lo:02X}, ${timer_hi:02X}  ; Frame {frame}")
                    
                    elif channel_name == 'noise':
                        volume = min(15, max(0, data['volume']))
                        period_index = 8  # default noise period
                        lines.append(f"    .byte ${volume:02X}, ${period_index:02X}  ; Frame {frame}")
                else:
                    # Silent frame
                    if config['bytes'] == 3:
                        lines.append(f"    .byte $00, $00, $00  ; Frame {frame} (silent)")
                    else:
                        lines.append(f"    .byte $00, $00  ; Frame {frame} (silent)")
        else:
            # Channel has no data - add single silent frame
            if config['bytes'] == 3:
                lines.append("    .byte $00, $00, $00  ; Silent frame")
            else:
                lines.append("    .byte $00, $00  ; Silent frame")
        lines.append("")
    
    # Export DPCM channel data if present
    if "dpcm" in frames_data and frames_data["dpcm"]:
        lines.append("; DPCM Channel Data")
        lines.append("dpcm_frames:")
        for frame in range(max_frame + 1):
            frame_str = str(frame)
            if frame_str in frames_data["dpcm"]:
                data = frames_data["dpcm"][frame_str]
                sample_id = data['sample_id']
                lines.append(f"    .byte ${sample_id:02X}  ; Frame {frame}")
            else:
                lines.append(f"    .byte $FF  ; Frame {frame} (no sample)")
        lines.append("")
    
    # Export music player routine
    lines.extend([
        "; Music Player Routine",
        ".segment \"CODE\"",
        "",
        ".proc play_music_frame",
        "    ; Input: A = frame number (low byte), X = frame number (high byte)",
        "    ; Destroys: A, X, Y",
        "    ",
        "    ; Calculate frame offset",
        "    sta temp_frame_lo",
        "    stx temp_frame_hi",
        "    ",
        "    ; Disable APU channels first",
        "    lda #$00",
        f"    sta ${APU_STATUS:04X}",
        "    ",
        "    ; Play Pulse 1",
        "    lda temp_frame_lo",
        "    asl",
        "    asl  ; multiply by 4 (3 bytes per frame + padding)",
        "    tax",
        "    lda pulse1_frames,x",
        f"    sta ${APU_PULSE1_CTRL:04X}",
        "    lda pulse1_frames+1,x",
        f"    sta ${APU_PULSE1_TIMER_LO:04X}",
        "    lda pulse1_frames+2,x",
        f"    sta ${APU_PULSE1_TIMER_HI:04X}",
        "    ",
        "    ; Play Pulse 2",
        "    lda temp_frame_lo",
        "    asl",
        "    asl",
        "    tax",
        "    lda pulse2_frames,x",
        f"    sta ${APU_PULSE2_CTRL:04X}",
        "    lda pulse2_frames+1,x",
        f"    sta ${APU_PULSE2_TIMER_LO:04X}",
        "    lda pulse2_frames+2,x",
        f"    sta ${APU_PULSE2_TIMER_HI:04X}",
        "    ",
        "    ; Play Triangle",
        "    lda temp_frame_lo",
        "    asl",
        "    asl",
        "    tax",
        "    lda triangle_frames,x",
        f"    sta ${APU_TRIANGLE_CTRL:04X}",
        "    lda triangle_frames+1,x",
        f"    sta ${APU_TRIANGLE_TIMER_LO:04X}",
        "    lda triangle_frames+2,x",
        f"    sta ${APU_TRIANGLE_TIMER_HI:04X}",
        "    ",
        "    ; Play Noise",
        "    lda temp_frame_lo",
        "    asl  ; multiply by 2 (2 bytes per frame)",
        "    tax",
        "    lda noise_frames,x",
        f"    sta ${APU_NOISE_CTRL:04X}",
        "    lda noise_frames+1,x",
        f"    sta ${APU_NOISE_PERIOD:04X}",
        "    lda #$08  ; Length counter",
        f"    sta ${APU_NOISE_LENGTH:04X}",
        "    ",
        "    ; Enable channels",
        "    lda #$0F  ; Enable pulse1, pulse2, triangle, noise",
        f"    sta ${APU_STATUS:04X}",
        "    ",
        "    rts",
        ".endproc",
        "",
        "; Variables",
        ".segment \"BSS\"",
        "temp_frame_lo: .res 1",
        "temp_frame_hi: .res 1",
        "current_frame: .res 2",
        "",
        "; Music initialization",
        ".segment \"CODE\"",
        ".proc init_music",
        "    ; Initialize APU",
        "    lda #$00",
        f"    sta ${APU_STATUS:04X}  ; Disable all channels",
        "    ",
        "    ; Clear frame counter",
        "    sta current_frame",
        "    sta current_frame+1",
        "    ",
        "    ; Enable channels",
        "    lda #$0F",
        f"    sta ${APU_STATUS:04X}",
        "    ",
        "    rts",
        ".endproc",
        "",
        "; Call this every frame (60Hz)",
        ".proc update_music",
        "    ; Load current frame",
        "    lda current_frame",
        "    ldx current_frame+1",
        "    ",
        "    ; Check if we've reached the end",
        f"    cmp #<music_frame_count",
        f"    bne :+",
        f"    cpx #>music_frame_count",
        f"    bcc :+",
        "    ; Reset to beginning",
        "    lda #$00",
        "    sta current_frame",
        "    sta current_frame+1",
        "    tax",
        ":",
        "    ; Play the frame",
        "    jsr play_music_frame",
        "    ",
        "    ; Increment frame counter",
        "    inc current_frame",
        "    bne :+",
        "    inc current_frame+1",
        ":",
        "    rts",
        ".endproc"
    ])
    
    # Write to file
    with open(output_path, 'w') as f:
        f.write('\n'.join(lines))


if __name__ == "__main__":
    import sys
    if len(sys.argv) != 3:
        print("Usage: python exporter_ca65.py <frames.json> <output.s>")
        sys.exit(1)
    
    with open(sys.argv[1], 'r') as f:
        frames = json.load(f)
    
    export_ca65_tables(frames, sys.argv[2])
    print(f"Exported CA65 assembly to {sys.argv[2]}")

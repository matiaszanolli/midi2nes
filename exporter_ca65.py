import json
from pathlib import Path

# NES APU register addresses
APU_PULSE1_CTRL = 0x4000
APU_PULSE1_SWEEP = 0x4001
APU_PULSE1_TIMER_LO = 0x4002
APU_PULSE1_TIMER_HI = 0x4003

APU_PULSE2_CTRL = 0x4004
APU_PULSE2_SWEEP = 0x4005
APU_PULSE2_TIMER_LO = 0x4006
APU_PULSE2_TIMER_HI = 0x4007

APU_TRIANGLE_CTRL = 0x4008
APU_TRIANGLE_TIMER_LO = 0x400A
APU_TRIANGLE_TIMER_HI = 0x400B

APU_NOISE_CTRL = 0x400C
APU_NOISE_PERIOD = 0x400E
APU_NOISE_LENGTH = 0x400F

APU_DMC_CTRL = 0x4010
APU_DMC_LOAD = 0x4011
APU_DMC_ADDR = 0x4012
APU_DMC_LEN = 0x4013

APU_STATUS = 0x4015

# NES note frequency table (NTSC)
# These are timer values for the APU pulse/triangle channels
NOTE_TABLE_NTSC = [
    # C    C#   D    D#   E    F    F#   G    G#   A    A#   B
    1712, 1616, 1525, 1440, 1357, 1281, 1209, 1141, 1077, 1017, 961, 907,  # Octave 1
    856,  808,  762,  720,  678,  640,  604,  570,  538,  508,  480, 453,   # Octave 2
    428,  404,  381,  360,  339,  320,  302,  285,  269,  254,  240, 226,   # Octave 3
    214,  202,  190,  180,  170,  160,  151,  143,  135,  127,  120, 113,   # Octave 4
    107,  101,  95,   90,   85,   80,   76,   71,   67,   64,   60,  57,    # Octave 5
    53,   50,   48,   45,   42,   40,   38,   36,   34,   32,   30,  28,    # Octave 6
    27,   25,   24,   22,   21,   20,   19,   18,   17,   16,   15,  14,    # Octave 7
    13,   13,   12,   11,   11,   10,   9,    9,    8,    8,    7,   7      # Octave 8
]

# Noise period table
NOISE_PERIODS = [4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068]

def midi_note_to_timer_value(midi_note):
    """Convert MIDI note number to NES timer value"""
    if midi_note < 24 or midi_note > 119:  # Valid range for NES
        return 0
    return NOTE_TABLE_NTSC[midi_note - 24]

def export_ca65_tables(frames_data, output_path):
    """Export frame data as CA65 assembly tables"""
    
    # Collect all unique frames and sort them
    all_frames = set()
    for channel_data in frames_data.values():
        all_frames.update(int(f) for f in channel_data.keys())
    
    if not all_frames:
        # Create empty file if no data
        with open(output_path, 'w') as f:
            f.write("; No audio data to export\n")
        return
    
    sorted_frames = sorted(all_frames)
    max_frame = max(sorted_frames)
    
    lines = []
    lines.append("; CA65 Assembly Export")
    lines.append("; Generated by MIDI2NES")
    lines.append("")
    lines.append(".segment \"RODATA\"")
    lines.append("")
    
    # Export frame count
    lines.append(f"music_frame_count = {max_frame + 1}")
    lines.append("")
    
    # Export pulse channel data
    for pulse_num in [1, 2]:
        channel_name = f"pulse{pulse_num}"
        if channel_name in frames_data and frames_data[channel_name]:
            lines.append(f"; Pulse {pulse_num} Channel Data")
            lines.append(f"pulse{pulse_num}_frames:")
            
            # Create frame-by-frame data
            for frame in range(max_frame + 1):
                frame_str = str(frame)
                if frame_str in frames_data[channel_name]:
                    data = frames_data[channel_name][frame_str]
                    timer_val = midi_note_to_timer_value(data['note'])
                    volume = min(15, max(0, data['volume']))
                    
                    # Duty cycle (default to 50%)
                    duty = 2  # 0=12.5%, 1=25%, 2=50%, 3=75%
                    ctrl_byte = (duty << 6) | volume
                    
                    timer_lo = timer_val & 0xFF
                    timer_hi = (timer_val >> 8) & 0x07
                    
                    lines.append(f"    .byte ${ctrl_byte:02X}, ${timer_lo:02X}, ${timer_hi:02X}  ; Frame {frame}")
                else:
                    # Silent frame
                    lines.append(f"    .byte $00, $00, $00  ; Frame {frame} (silent)")
            lines.append("")
    
    # Export triangle channel data
    if "triangle" in frames_data and frames_data["triangle"]:
        lines.append("; Triangle Channel Data")
        lines.append("triangle_frames:")
        
        for frame in range(max_frame + 1):
            frame_str = str(frame)
            if frame_str in frames_data["triangle"]:
                data = frames_data["triangle"][frame_str]
                timer_val = midi_note_to_timer_value(data['note'])
                volume = data['volume']
                
                # Triangle has no volume control, only on/off
                ctrl_byte = 0x80 if volume > 0 else 0x00  # Linear counter control
                timer_lo = timer_val & 0xFF
                timer_hi = (timer_val >> 8) & 0x07
                
                lines.append(f"    .byte ${ctrl_byte:02X}, ${timer_lo:02X}, ${timer_hi:02X}  ; Frame {frame}")
            else:
                lines.append(f"    .byte $00, $00, $00  ; Frame {frame} (silent)")
        lines.append("")
    
    # Export noise channel data
    if "noise" in frames_data and frames_data["noise"]:
        lines.append("; Noise Channel Data")
        lines.append("noise_frames:")
        
        for frame in range(max_frame + 1):
            frame_str = str(frame)
            if frame_str in frames_data["noise"]:
                data = frames_data["noise"][frame_str]
                volume = min(15, max(0, data['volume']))
                
                # Use a default noise period (index 8 = period 202)
                period_index = 8
                ctrl_byte = volume
                period_byte = period_index
                
                lines.append(f"    .byte ${ctrl_byte:02X}, ${period_byte:02X}  ; Frame {frame}")
            else:
                lines.append(f"    .byte $00, $00  ; Frame {frame} (silent)")
        lines.append("")
    
    # Export DPCM channel data
    if "dpcm" in frames_data and frames_data["dpcm"]:
        lines.append("; DPCM Channel Data")
        lines.append("dpcm_frames:")
        
        for frame in range(max_frame + 1):
            frame_str = str(frame)
            if frame_str in frames_data["dpcm"]:
                data = frames_data["dpcm"][frame_str]
                sample_id = data['sample_id']
                
                lines.append(f"    .byte ${sample_id:02X}  ; Frame {frame}")
            else:
                lines.append(f"    .byte $FF  ; Frame {frame} (no sample)")
        lines.append("")
    
    # Export music player routine
    lines.extend([
        "; Music Player Routine",
        ".segment \"CODE\"",
        "",
        ".proc play_music_frame",
        "    ; Input: A = frame number (low byte), X = frame number (high byte)",
        "    ; Destroys: A, X, Y",
        "    ",
        "    ; Calculate frame offset",
        "    sta temp_frame_lo",
        "    stx temp_frame_hi",
        "    ",
        "    ; Disable APU channels first",
        "    lda #$00",
        f"    sta ${APU_STATUS:04X}",
        "    ",
        "    ; Play Pulse 1",
        "    lda temp_frame_lo",
        "    asl",
        "    asl  ; multiply by 4 (3 bytes per frame + padding)",
        "    tax",
        "    lda pulse1_frames,x",
        f"    sta ${APU_PULSE1_CTRL:04X}",
        "    lda pulse1_frames+1,x",
        f"    sta ${APU_PULSE1_TIMER_LO:04X}",
        "    lda pulse1_frames+2,x",
        f"    sta ${APU_PULSE1_TIMER_HI:04X}",
        "    ",
        "    ; Play Pulse 2",
        "    lda temp_frame_lo",
        "    asl",
        "    asl",
        "    tax",
        "    lda pulse2_frames,x",
        f"    sta ${APU_PULSE2_CTRL:04X}",
        "    lda pulse2_frames+1,x",
        f"    sta ${APU_PULSE2_TIMER_LO:04X}",
        "    lda pulse2_frames+2,x",
        f"    sta ${APU_PULSE2_TIMER_HI:04X}",
        "    ",
        "    ; Play Triangle",
        "    lda temp_frame_lo",
        "    asl",
        "    asl",
        "    tax",
        "    lda triangle_frames,x",
        f"    sta ${APU_TRIANGLE_CTRL:04X}",
        "    lda triangle_frames+1,x",
        f"    sta ${APU_TRIANGLE_TIMER_LO:04X}",
        "    lda triangle_frames+2,x",
        f"    sta ${APU_TRIANGLE_TIMER_HI:04X}",
        "    ",
        "    ; Play Noise",
        "    lda temp_frame_lo",
        "    asl  ; multiply by 2 (2 bytes per frame)",
        "    tax",
        "    lda noise_frames,x",
        f"    sta ${APU_NOISE_CTRL:04X}",
        "    lda noise_frames+1,x",
        f"    sta ${APU_NOISE_PERIOD:04X}",
        "    lda #$08  ; Length counter",
        f"    sta ${APU_NOISE_LENGTH:04X}",
        "    ",
        "    ; Enable channels",
        "    lda #$0F  ; Enable pulse1, pulse2, triangle, noise",
        f"    sta ${APU_STATUS:04X}",
        "    ",
        "    rts",
        ".endproc",
        "",
        "; Variables",
        ".segment \"BSS\"",
        "temp_frame_lo: .res 1",
        "temp_frame_hi: .res 1",
        "current_frame: .res 2",
        "",
        "; Music initialization",
        ".segment \"CODE\"",
        ".proc init_music",
        "    ; Initialize APU",
        "    lda #$00",
        f"    sta ${APU_STATUS:04X}  ; Disable all channels",
        "    ",
        "    ; Clear frame counter",
        "    sta current_frame",
        "    sta current_frame+1",
        "    ",
        "    ; Enable channels",
        "    lda #$0F",
        f"    sta ${APU_STATUS:04X}",
        "    ",
        "    rts",
        ".endproc",
        "",
        "; Call this every frame (60Hz)",
        ".proc update_music",
        "    ; Load current frame",
        "    lda current_frame",
        "    ldx current_frame+1",
        "    ",
        "    ; Check if we've reached the end",
        f"    cmp #<music_frame_count",
        f"    bne :+",
        f"    cpx #>music_frame_count",
        f"    bcc :+",
        "    ; Reset to beginning",
        "    lda #$00",
        "    sta current_frame",
        "    sta current_frame+1",
        "    tax",
        ":",
        "    ; Play the frame",
        "    jsr play_music_frame",
        "    ",
        "    ; Increment frame counter",
        "    inc current_frame",
        "    bne :+",
        "    inc current_frame+1",
        ":",
        "    rts",
        ".endproc"
    ])
    
    # Write to file
    with open(output_path, 'w') as f:
        f.write('\n'.join(lines))

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 3:
        print("Usage: python exporter_ca65.py <frames.json> <output.s>")
        sys.exit(1)
    
    with open(sys.argv[1], 'r') as f:
        frames = json.load(f)
    
    export_ca65_tables(frames, sys.argv[2])
    print(f"Exported CA65 assembly to {sys.argv[2]}")

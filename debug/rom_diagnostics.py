#!/usr/bin/env python3
"""
MIDI2NES ROM Diagnostics Tool
============================

Comprehensive ROM validation and debugging tool for NES ROMs generated by MIDI2NES.
This tool consolidates all ROM health checks into a single, easy-to-use interface.

Usage:
    python debug/rom_diagnostics.py [ROM_FILE] [--verbose] [--output FORMAT]

Examples:
    python debug/rom_diagnostics.py corrected.nes
    python debug/rom_diagnostics.py input.nes --verbose
    python debug/rom_diagnostics.py *.nes --output json
"""

import os
import sys
import struct
import json
import argparse
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass, asdict


@dataclass
class ROMDiagnosticResult:
    """Container for ROM diagnostic results."""
    file_path: str
    file_size: int
    is_valid_nes: bool
    prg_banks: int
    chr_banks: int
    expected_size: int
    size_mismatch: int
    zero_byte_percent: float
    repeated_chunks_percent: float
    reset_vectors: Dict[str, int]
    reset_vectors_valid: bool
    apu_pattern_count: int
    pattern_data_density: float
    assembly_code_score: int
    overall_health: str
    issues: List[str]
    recommendations: List[str]


class ROMDiagnostics:
    """Comprehensive ROM diagnostics and validation."""
    
    # APU register patterns to look for
    APU_PATTERNS = [
        (b'\xA9\x0F\x8D\x15\x40', "APU Enable ($0F → $4015)", "critical"),
        (b'\xA9\xBF\x8D\x00\x40', "Pulse1 Init ($BF → $4000)", "good"),
        (b'\xA9\x30\x8D\x00\x40', "Pulse1 Init ($30 → $4000)", "bad"),
        (b'\xA9\xBF\x8D\x04\x40', "Pulse2 Init ($BF → $4004)", "good"),
        (b'\xA9\x30\x8D\x04\x40', "Pulse2 Init ($30 → $4004)", "bad"),
        (b'\x8D\x00\x40', "Write to $4000 (Pulse1)", "normal"),
        (b'\x8D\x04\x40', "Write to $4004 (Pulse2)", "normal"),
        (b'\x8D\x08\x40', "Write to $4008 (Triangle)", "normal"),
        (b'\x8D\x0C\x40', "Write to $400C (Noise)", "normal"),
        (b'\x8D\x15\x40', "Write to $4015 (APU Control)", "critical"),
    ]
    
    # Common 6502 opcodes for assembly analysis
    ASSEMBLY_PATTERNS = [
        (b'\xA9', "LDA immediate"),
        (b'\x8D', "STA absolute"),
        (b'\xA2', "LDX immediate"),
        (b'\xA0', "LDY immediate"),
        (b'\x4C', "JMP absolute"),
        (b'\x20', "JSR"),
        (b'\x60', "RTS"),
        (b'\x10', "BPL"),
        (b'\x30', "BMI"),
        (b'\xF0', "BEQ"),
        (b'\xD0', "BNE"),
    ]

    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        
    def diagnose_rom(self, rom_path: str) -> ROMDiagnosticResult:
        """Perform comprehensive ROM diagnostics."""
        if not os.path.exists(rom_path):
            return self._create_error_result(rom_path, f"ROM file {rom_path} not found!")
        
        try:
            with open(rom_path, 'rb') as f:
                rom_data = f.read()
            
            file_size = len(rom_data)
            
            # Parse iNES header
            if len(rom_data) < 16 or rom_data[0:4] != b'NES\x1a':
                return self._create_error_result(rom_path, "Invalid iNES header!")
            
            header = rom_data[0:16]
            prg_banks = header[4]
            chr_banks = header[5]
            prg_size = prg_banks * 16384
            chr_size = chr_banks * 8192
            expected_size = 16 + prg_size + chr_size
            
            # Extract PRG data for analysis
            prg_data = rom_data[16:16+prg_size] if prg_size > 0 else b''
            
            # Perform all diagnostic checks
            zero_percent = self._check_zero_bytes(prg_data)
            repeat_percent = self._check_repeated_chunks(prg_data)
            vectors, vectors_valid = self._check_reset_vectors(prg_data)
            apu_count = self._check_apu_patterns(rom_data)
            pattern_density = self._check_pattern_density(rom_data)
            assembly_score = self._check_assembly_patterns(prg_data)
            
            # Determine overall health and issues
            issues = []
            recommendations = []
            
            size_mismatch = file_size - expected_size
            if size_mismatch != 0:
                issues.append(f"Size mismatch: {abs(size_mismatch)} bytes {'larger' if size_mismatch > 0 else 'smaller'} than expected")
                if abs(size_mismatch) > 10:
                    recommendations.append("Check linker configuration for correct memory layout")
            
            if zero_percent > 70:
                issues.append(f"Excessive zero bytes ({zero_percent:.1f}%)")
                recommendations.append("ROM may be corrupted or improperly generated")
            
            if repeat_percent > 80:
                issues.append(f"Excessive repetition ({repeat_percent:.1f}%)")
                recommendations.append("Check for infinite loops in pattern generation")
            
            if not vectors_valid:
                issues.append("Invalid reset vectors")
                recommendations.append("Verify linker script places reset vectors correctly at $FFFA-$FFFF")
            
            if apu_count == 0:
                issues.append("No APU initialization code found")
                recommendations.append("Ensure music player initialization code is included")
            
            if pattern_density < 5:
                issues.append(f"Low pattern data density ({pattern_density:.1f}%)")
                recommendations.append("Check if MIDI data was properly converted to patterns")
            
            if assembly_score < 50:
                issues.append(f"Low assembly code activity (score: {assembly_score})")
                if prg_banks <= 2:
                    recommendations.append("Low activity may be normal for music-only ROMs")
                else:
                    recommendations.append("ROM may be missing essential code sections")
            
            # Determine overall health
            if not issues:
                overall_health = "HEALTHY"
            elif len(issues) <= 2 and all("Low assembly" in issue or "Size mismatch" in issue for issue in issues):
                overall_health = "GOOD"
            elif len(issues) <= 3:
                overall_health = "FAIR"
            else:
                overall_health = "POOR"
            
            return ROMDiagnosticResult(
                file_path=rom_path,
                file_size=file_size,
                is_valid_nes=True,
                prg_banks=prg_banks,
                chr_banks=chr_banks,
                expected_size=expected_size,
                size_mismatch=size_mismatch,
                zero_byte_percent=zero_percent,
                repeated_chunks_percent=repeat_percent,
                reset_vectors=vectors,
                reset_vectors_valid=vectors_valid,
                apu_pattern_count=apu_count,
                pattern_data_density=pattern_density,
                assembly_code_score=assembly_score,
                overall_health=overall_health,
                issues=issues,
                recommendations=recommendations
            )
            
        except Exception as e:
            return self._create_error_result(rom_path, f"Error reading ROM: {str(e)}")
    
    def _create_error_result(self, rom_path: str, error_msg: str) -> ROMDiagnosticResult:
        """Create a result object for error cases."""
        return ROMDiagnosticResult(
            file_path=rom_path,
            file_size=0,
            is_valid_nes=False,
            prg_banks=0,
            chr_banks=0,
            expected_size=0,
            size_mismatch=0,
            zero_byte_percent=0.0,
            repeated_chunks_percent=0.0,
            reset_vectors={},
            reset_vectors_valid=False,
            apu_pattern_count=0,
            pattern_data_density=0.0,
            assembly_code_score=0,
            overall_health="ERROR",
            issues=[error_msg],
            recommendations=["Ensure ROM file exists and is readable"]
        )
    
    def _check_zero_bytes(self, prg_data: bytes) -> float:
        """Check percentage of zero bytes in PRG data."""
        if not prg_data:
            return 0.0
        return (prg_data.count(0) / len(prg_data)) * 100
    
    def _check_repeated_chunks(self, prg_data: bytes, chunk_size: int = 256) -> float:
        """Check for repeated chunks in PRG data."""
        if len(prg_data) < chunk_size:
            return 0.0
        
        chunks = [prg_data[i:i+chunk_size] for i in range(0, len(prg_data), chunk_size)]
        unique_chunks = len(set(chunks))
        return ((len(chunks) - unique_chunks) / len(chunks)) * 100
    
    def _check_reset_vectors(self, prg_data: bytes) -> Tuple[Dict[str, int], bool]:
        """Check reset vectors at end of PRG data."""
        if len(prg_data) < 6:
            return {}, False
        
        vectors_data = prg_data[-6:]
        nmi_vec = struct.unpack('<H', vectors_data[0:2])[0]
        rst_vec = struct.unpack('<H', vectors_data[2:4])[0]
        irq_vec = struct.unpack('<H', vectors_data[4:6])[0]
        
        vectors = {
            'NMI': nmi_vec,
            'RESET': rst_vec,
            'IRQ': irq_vec
        }
        
        # Vectors should point to ROM space ($8000-$FFFF) or be $FFFF (unimplemented)
        valid = all(0x8000 <= vec <= 0xFFFF for vec in vectors.values())
        
        return vectors, valid
    
    def _check_apu_patterns(self, rom_data: bytes) -> int:
        """Check for APU-related code patterns."""
        total_count = 0
        
        if self.verbose:
            print("🎵 APU Pattern Analysis:")
        
        for pattern, description, priority in self.APU_PATTERNS:
            count = rom_data.count(pattern)
            total_count += count
            
            if self.verbose and count > 0:
                status = "🔴" if priority == "bad" else ("🟢" if priority == "good" else "🔵")
                print(f"  {status} {description}: {count} occurrences")
        
        return total_count
    
    def _check_pattern_density(self, rom_data: bytes) -> float:
        """Check density of potential pattern data."""
        if len(rom_data) < 116:  # Skip header + minimum content
            return 0.0
        
        pattern_candidates = 0
        # Analyze chunks for pattern-like data
        for i in range(16, len(rom_data) - 20):  # Skip header
            chunk = rom_data[i:i+20]
            # Pattern data should have variety but not be all zeros
            if len(set(chunk)) > 3 and chunk.count(0) < 15:
                pattern_candidates += 1
        
        return (pattern_candidates / (len(rom_data) - 36)) * 100
    
    def _check_assembly_patterns(self, prg_data: bytes) -> int:
        """Analyze assembly code patterns in PRG data."""
        score = 0
        
        if self.verbose:
            print("💻 Assembly Pattern Analysis:")
        
        for pattern, description in self.ASSEMBLY_PATTERNS:
            count = prg_data.count(pattern)
            contribution = min(count, 20)  # Cap contribution per pattern
            score += contribution
            
            if self.verbose and count > 0:
                print(f"  {description}: {count} occurrences (+{contribution} points)")
        
        return score
    
    def print_report(self, result: ROMDiagnosticResult, format: str = "human"):
        """Print diagnostic report in specified format."""
        if format == "json":
            print(json.dumps(asdict(result), indent=2))
            return
        
        # Human-readable format
        health_emoji = {
            "HEALTHY": "🟢",
            "GOOD": "🟡", 
            "FAIR": "🟠",
            "POOR": "🔴",
            "ERROR": "❌"
        }
        
        print(f"\n{'='*60}")
        print(f"🔍 MIDI2NES ROM Diagnostics Report")
        print(f"{'='*60}")
        print(f"📁 File: {result.file_path}")
        print(f"📊 Size: {result.file_size:,} bytes")
        
        if not result.is_valid_nes:
            print(f"❌ {result.issues[0]}")
            return
        
        print(f"🎮 Format: iNES (PRG: {result.prg_banks} banks, CHR: {result.chr_banks} banks)")
        print(f"📐 Expected size: {result.expected_size:,} bytes")
        
        if result.size_mismatch != 0:
            print(f"⚠️  Size difference: {result.size_mismatch:+,} bytes")
        else:
            print(f"✅ Size matches header")
        
        print(f"\n🔍 Content Analysis:")
        print(f"   Zero bytes: {result.zero_byte_percent:.1f}% {'❌' if result.zero_byte_percent > 70 else '✅'}")
        print(f"   Repetition: {result.repeated_chunks_percent:.1f}% {'❌' if result.repeated_chunks_percent > 80 else '✅'}")
        print(f"   Pattern density: {result.pattern_data_density:.1f}% {'❌' if result.pattern_data_density < 5 else '✅'}")
        print(f"   Assembly score: {result.assembly_code_score}/220 {'❌' if result.assembly_code_score < 50 else '✅'}")
        print(f"   APU patterns: {result.apu_pattern_count} {'❌' if result.apu_pattern_count == 0 else '✅'}")
        
        if result.reset_vectors:
            print(f"\n🎯 Reset Vectors:")
            for name, addr in result.reset_vectors.items():
                status = "✅" if 0x8000 <= addr <= 0xFFFF else "❌"
                print(f"   {name}: ${addr:04X} {status}")
        
        print(f"\n{health_emoji.get(result.overall_health, '❓')} Overall Health: {result.overall_health}")
        
        if result.issues:
            print(f"\n❌ Issues Found ({len(result.issues)}):")
            for i, issue in enumerate(result.issues, 1):
                print(f"   {i}. {issue}")
        
        if result.recommendations:
            print(f"\n💡 Recommendations:")
            for i, rec in enumerate(result.recommendations, 1):
                print(f"   {i}. {rec}")
        
        print(f"{'='*60}\n")


def main():
    """Main CLI entry point."""
    parser = argparse.ArgumentParser(
        description="Comprehensive ROM diagnostics for MIDI2NES generated ROMs",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s corrected.nes                    # Basic health check
  %(prog)s input.nes --verbose              # Detailed analysis  
  %(prog)s *.nes --output json              # JSON output for multiple files
  %(prog)s broken.nes --output human        # Human-readable report
        """
    )
    
    parser.add_argument(
        'rom_files',
        nargs='+',
        help='ROM file(s) to analyze'
    )
    
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Enable verbose output with detailed pattern analysis'
    )
    
    parser.add_argument(
        '--output', '-o',
        choices=['human', 'json'],
        default='human',
        help='Output format (default: human)'
    )
    
    args = parser.parse_args()
    
    diagnostics = ROMDiagnostics(verbose=args.verbose)
    results = []
    
    # Process each ROM file
    for rom_file in args.rom_files:
        try:
            result = diagnostics.diagnose_rom(rom_file)
            results.append(result)
            
            if args.output == 'human':
                diagnostics.print_report(result, 'human')
            
        except Exception as e:
            print(f"❌ Error processing {rom_file}: {e}", file=sys.stderr)
    
    # For JSON output, print all results together
    if args.output == 'json':
        if len(results) == 1:
            print(json.dumps(asdict(results[0]), indent=2))
        else:
            print(json.dumps([asdict(r) for r in results], indent=2))
    
    # Summary for multiple files
    if len(results) > 1 and args.output == 'human':
        print(f"\n📊 Summary of {len(results)} ROM files:")
        healthy = sum(1 for r in results if r.overall_health in ['HEALTHY', 'GOOD'])
        print(f"   🟢 Healthy/Good: {healthy}")
        print(f"   ⚠️  Issues: {len(results) - healthy}")
    
    # Exit code based on results
    if all(r.overall_health in ['HEALTHY', 'GOOD'] for r in results):
        sys.exit(0)
    else:
        sys.exit(1)


if __name__ == "__main__":
    main()

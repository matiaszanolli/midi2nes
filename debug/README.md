# MIDI2NES Debug Tools

Essential debugging and validation tools for MIDI2NES ROM generation.

## Overview

This directory contains consolidated debug tools designed to diagnose and validate NES ROMs generated by the MIDI2NES pipeline. The tools are streamlined, easy to use, and provide actionable feedback for ROM corruption or generation issues.

## Tools

### 🔍 `rom_diagnostics.py` - Comprehensive ROM Analysis

The main diagnostic tool that performs complete ROM health checks and validation.

**Features:**
- Header validation (PRG/CHR banks, size matching)
- Corruption detection (zero bytes, repetition patterns)
- Reset vector validation
- APU code pattern detection  
- Assembly code analysis
- Pattern data density checking
- Detailed recommendations

**Usage:**
```bash
# Basic analysis
python debug/rom_diagnostics.py corrected.nes

# Detailed verbose analysis  
python debug/rom_diagnostics.py input.nes --verbose

# Multiple files with JSON output
python debug/rom_diagnostics.py *.nes --output json

# Compare before/after
python debug/rom_diagnostics.py input.nes corrected.nes
```

**Sample Output:**
```
============================================================
🔍 MIDI2NES ROM Diagnostics Report
============================================================
📁 File: corrected.nes
📊 Size: 32,783 bytes
🎮 Format: iNES (PRG: 2 banks, CHR: 0 banks)
📐 Expected size: 32,784 bytes
⚠️  Size difference: -1 bytes

🔍 Content Analysis:
   Zero bytes: 44.9% ✅
   Repetition: 40.6% ✅
   Pattern density: 12.2% ✅
   Assembly score: 34/220 ❌
   APU patterns: 10 ✅

🎯 Reset Vectors:
   NMI: $FFFF ✅
   RESET: $FFFF ✅
   IRQ: $FFFF ✅

🟡 Overall Health: GOOD

❌ Issues Found (2):
   1. Size mismatch: 1 bytes smaller than expected
   2. Low assembly code activity (score: 34)

💡 Recommendations:
   1. Low activity may be normal for music-only ROMs
```

### 🚀 `check_rom.py` - Quick Health Check

Simplified interface for quick ROM validation with minimal output.

**Usage:**
```bash
# Quick check
python debug/check_rom.py corrected.nes
```

**Sample Output:**
```
🔍 Quick ROM Health Check
========================================
🟡 corrected.nes: GOOD
   📊 32,783 bytes (2 PRG banks)

✅ ROM appears healthy!
```

## Health Classifications

| Status | Icon | Description |
|--------|------|-------------|
| **HEALTHY** | 🟢 | Perfect ROM with no issues |
| **GOOD** | 🟡 | Minor issues that don't affect functionality |
| **FAIR** | 🟠 | Some issues that may cause problems |
| **POOR** | 🔴 | Major issues, ROM likely corrupted |
| **ERROR** | ❌ | Cannot read or invalid ROM file |

## Common Issues & Solutions

### 🔴 Size Mismatch
**Problem:** ROM file size doesn't match header expectations
**Solutions:**
- Check linker configuration memory layout
- Verify PRG/CHR bank count in header
- Ensure reset vectors are properly placed

### 🔴 Excessive Zero Bytes (>70%)
**Problem:** ROM contains too many zeros, indicating corruption
**Solutions:**
- Regenerate ROM from source
- Check MIDI input for valid data
- Verify pattern generation pipeline

### 🔴 Invalid Reset Vectors
**Problem:** Reset vectors don't point to valid ROM addresses
**Solutions:**
- Check linker script vector placement
- Ensure vectors are at $FFFA-$FFFF
- Verify code section layout

### 🔴 No APU Code Found
**Problem:** No audio initialization patterns detected
**Solutions:**
- Check if music player code is included
- Verify APU initialization in main.asm
- Ensure sound data is properly linked

### 🟡 Low Assembly Activity
**Problem:** Minimal assembly code patterns detected
**Note:** This may be normal for music-only ROMs with mostly data

## Integration with MIDI2NES Pipeline

### Automatic Validation
Add ROM validation to your build process:

```bash
# After ROM generation
python main.py input.mid output.nes
python debug/check_rom.py output.nes || echo "ROM validation failed!"
```

### CI/CD Integration
Use JSON output for automated testing:

```bash
python debug/rom_diagnostics.py *.nes --output json | jq '.overall_health'
```

### Development Workflow
1. Generate ROM with MIDI2NES
2. Quick check with `check_rom.py`
3. If issues found, detailed analysis with `rom_diagnostics.py --verbose`
4. Apply recommended fixes
5. Regenerate and validate

## Exit Codes

- `0`: All ROMs healthy/good
- `1`: Issues found in one or more ROMs

This makes the tools suitable for use in scripts and CI/CD pipelines.

## Legacy Tools

Previous debug tools have been archived in `debug_backup_*` directories. The new consolidated tools provide all the functionality in a cleaner, more maintainable format.
